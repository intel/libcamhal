<?xml version="1.0" encoding="utf-8"?>
<!-- Copyright (C) 2012 The Android Open Source Project
     Copyright (C) 2016 Intel Corporation

     Licensed under the Apache License, Version 2.0 (the "License");
     you may not use this file except in compliance with the License.
     You may obtain a copy of the License at

          http://www.apache.org/licenses/LICENSE-2.0

     Unless required by applicable law or agreed to in writing, software
     distributed under the License is distributed on an "AS IS" BASIS,
     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     See the License for the specific language governing permissions and
     limitations under the License.
-->
<metadata xmlns="http://schemas.android.com/service/camera/metadata/"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://schemas.android.com/service/camera/metadata/ metadata_properties.xsd">

  <tags>
    <tag id="BC">
        Basic camera features
    </tag>
    <tag id="V1">
        New features for first camera 2 release (API1)
    </tag>
    <tag id="RAW">
        Needed for useful RAW image processing and DNG file support
    </tag>
    <tag id="HAL2">
        Entry is only used by camera device HAL 2.x
    </tag>
    <tag id="FULL">
        Entry is required for full hardware level devices, and optional for other hardware levels
    </tag>
    <tag id="FUTURE">
        Entry is  under-specified and is not required/plan to support now. This is for book-keeping purpose,
        do not implement or use it, it may be revised for future.
    </tag>
    <tag id="HALV3">
        Entry is only used for metadata transfer to align with camera HAL V3.
    </tag>
  </tags>

  <types>
    <typedef name="pairFloatFloat">
      <language name="java">camera.util.Pair&lt;Float,Float&gt;</language>
    </typedef>
    <typedef name="pairDoubleDouble">
      <language name="java">camera.util.Pair&lt;Double,Double&gt;</language>
    </typedef>
    <typedef name="rectangle">
      <language name="java">camera.graphics.Rect</language>
    </typedef>
    <typedef name="size">
      <language name="java">camera.util.Size</language>
    </typedef>
    <typedef name="string">
      <language name="java">String</language>
    </typedef>
    <typedef name="boolean">
      <language name="java">boolean</language>
    </typedef>
    <typedef name="imageFormat">
      <language name="java">int</language>
    </typedef>
    <typedef name="streamConfigurationMap">
      <language name="java">camera.hardware.camera2.params.StreamConfigurationMap</language>
    </typedef>
    <typedef name="streamConfiguration">
      <language name="java">camera.hardware.camera2.params.StreamConfiguration</language>
    </typedef>
    <typedef name="streamConfigurationDuration">
      <language name="java">camera.hardware.camera2.params.StreamConfigurationDuration</language>
    </typedef>
    <typedef name="face">
      <language name="java">camera.hardware.camera2.params.Face</language>
    </typedef>
    <typedef name="meteringRectangle">
      <language name="java">camera.hardware.camera2.params.MeteringRectangle</language>
    </typedef>
    <typedef name="rangeFloat">
      <language name="java">camera.util.Range&lt;Float&gt;</language>
    </typedef>
    <typedef name="rangeInt">
      <language name="java">camera.util.Range&lt;Integer&gt;</language>
    </typedef>
    <typedef name="rangeLong">
      <language name="java">camera.util.Range&lt;Long&gt;</language>
    </typedef>
    <typedef name="colorSpaceTransform">
      <language name="java">camera.hardware.camera2.params.ColorSpaceTransform</language>
    </typedef>
    <typedef name="rggbChannelVector">
      <language name="java">camera.hardware.camera2.params.RggbChannelVector</language>
    </typedef>
    <typedef name="blackLevelPattern">
      <language name="java">camera.hardware.camera2.params.BlackLevelPattern</language>
    </typedef>
    <typedef name="enumList">
      <language name="java">int</language>
    </typedef>
    <typedef name="sizeF">
      <language name="java">camera.util.SizeF</language>
    </typedef>
    <typedef name="point">
      <language name="java">camera.graphics.Point</language>
    </typedef>
    <typedef name="tonemapCurve">
      <language name="java">camera.hardware.camera2.params.TonemapCurve</language>
    </typedef>
    <typedef name="lensShadingMap">
      <language name="java">camera.hardware.camera2.params.LensShadingMap</language>
    </typedef>
    <typedef name="location">
      <language name="java">camera.location.Location</language>
    </typedef>
    <typedef name="highSpeedVideoConfiguration">
      <language name="java">camera.hardware.camera2.params.HighSpeedVideoConfiguration</language>
    </typedef>
  </types>

  <namespace name="camera">
    <section name="ae">
      <controls>
        <entry name="mode" type="byte" visibility="public" enum="true">
          <enum>
            <value>MANUAL
              <notes>
                The camera device's autoexposure routine is disabled.

                The application-selected camera.sensor.exposureTime, camera.sensor.sensitivity and
                camera.sensor.frameDuration are used by the camera device, along with
                camera.flash.* fields, if there's a flash unit for this camera device.

                Note that auto-white balance (AWB) and auto-focus (AF) behavior is device dependent
                when AE is in OFF mode. To have consistent behavior across different devices, it is
                recommended to either set AWB and AF to OFF mode or lock AWB and AF before setting
                AE to OFF. See camera.awb.mode, camera.af.mode, camera.awb.lock, and
                camera.af.trigger for more details.

                LEGACY devices do not support the OFF mode and will override attempts to use this
                value to AUTO.
              </notes>
            </value>
            <value>AUTO
              <notes>
                The camera device's autoexposure routine is active, with no flash control.

                The application's values for camera.sensor.exposureTime, camera.sensor.sensitivity,
                and camera.sensor.frameDuration are ignored. The application has control over the
                various camera.flash.* fields.
              </notes>
            </value>
          </enum>
          <description>
            The desired mode for the camera device's auto-exposure routine.
          </description>
          <range>camera.ae.availableModes</range>
          <details>
            This control is only effective if camera.control.mode is AUTO.

            When set to the AUTO mode, the camera device's auto-exposure routine is enabled,
            overriding the application's selected exposure time, sensor sensitivity, and frame
            duration (camera.sensor.exposureTime, camera.sensor.sensitivity, and
            camera.sensor.frameDuration).

            When set to the AUTO modes, the values chosen by the camera device auto-exposure
            routine for the overridden fields for a given capture will be available in its
            CaptureResult.
          </details>
        </entry>

        <entry name="lock" type="byte" visibility="public" enum="true" typedef="boolean">
          <enum>
            <value>OFF
              <notes>
                Auto-exposure lock is disabled; the AE algorithm is free to update its parameters.
              </notes>
            </value>
            <value>ON
              <notes>
                Auto-exposure lock is enabled; the AE algorithm must not update the exposure and
                sensitivity parameters while the lock is active.

                camera.ae.compensation setting changes will still take effect while auto-exposure
                is locked.
              </notes>
            </value>
          </enum>
          <description>
            Whether auto-exposure (AE) is currently locked to its latest calculated values.
          </description>
          <details>
            When set to `true` (ON), the AE algorithm is locked to its latest parameters, and will
            not change exposure settings until the lock is set to `false` (OFF).

            Note that even when AE is locked, the flash may be fired.

            When camera.ae.compensation is changed, even if the AE lock is ON, the camera device
            will still adjust its exposure value.

            If AE precapture is triggered (see camera.ae.precaptureTrigger) when AE is
            already locked, the camera device will not change the exposure time
            (camera.sensor.exposureTime) and sensitivity (camera.sensor.sensitivity) parameters.

            Since the camera device has a pipeline of in-flight requests, the settings that get
            locked do not necessarily correspond to the settings that were present in the latest
            capture result received from the camera device, since additional captures and AE
            updates may have occurred even before the result was sent out. If an application is
            switching between automatic and manual control and wishes to eliminate any flicker
            during the switch, the following procedure is recommended:

            1. Starting in auto-AE mode:
            2. Lock AE
            3. Wait for the first result to be output that has the AE locked
            4. Copy exposure settings from that result into a request, set the request to manual AE
            5. Submit the capture request, proceed to run manual AE as desired.

            See camera.ae.state for AE lock related state transition details.
          </details>
          <tag id="FUTURE" />
        </entry>

        <entry name="regions" type="int32" visibility="public"
            optional="true" container="array" typedef="meteringRectangle">
          <array>
            <size>5</size>
            <size>area_count</size>
          </array>
          <description>List of metering areas to use for auto-exposure adjustment.</description>
          <units>Pixel coordinates within camera.sensor.info.activeArraySize</units>
          <range>Coordinates must be between `[(0,0), (width, height))` of
          camera.sensor.info.activeArraySize</range>
          <details>
              Not available if the AE value of camera.control.maxRegions is 0.
              Otherwise will always be present.

              The maximum number of regions supported by the device is determined by the AE value
              of camera.control.maxRegions.

              The coordinate system is based on the active pixel array,
              with (0,0) being the top-left pixel in the active pixel array, and
              (camera.sensor.info.activeArraySize.width - 1,
              camera.sensor.info.activeArraySize.height - 1) being the
              bottom-right pixel in the active pixel array.

              The weight must be within `[0, 1000]`, and represents a weight
              for every pixel in the area. This means that a large metering area
              with the same weight as a smaller area will have more effect in
              the metering result. Metering areas can partially overlap and the
              camera device will add the weights in the overlap region.

              The weights are relative to weights of other exposure metering regions, so if only one
              region is used, all non-zero weights will have the same effect. A region with 0
              weight is ignored.

              If all regions have 0 weight, then no specific metering area needs to be used by the
              camera device.

              If the metering region is outside the used camera.scaler.cropRegion returned in
              capture result metadata, the camera device will ignore the sections outside the crop
              region and output only the intersection rectangle as the metering region in the result
              metadata.  If the region is entirely outside the crop region, it will be ignored and
              not reported in the result metadata.

              Every metering rectangle is defined as (left, top, right, bottom, weight),
              inclusive on left and top, but exclusive on right and bottom.
          </details>
        </entry>

        <entry name="antibandingMode" type="byte" visibility="public" enum="true">
          <enum>
            <value>AUTO
              <notes>
                The camera device will automatically adapt its antibanding routine to the current
                illumination condition. This is the default mode if AUTO is available on given
                camera device.
              </notes>
            </value>
            <value>50HZ
              <notes>
                The camera device will adjust exposure duration to avoid banding problems with
                50Hz illumination sources.
              </notes>
            </value>
            <value>60HZ
              <notes>
                The camera device will adjust exposure duration to avoid banding problems with
                60Hz illumination sources.
              </notes>
            </value>
            <value>OFF
              <notes>
                The camera device will not adjust exposure duration to avoid banding problems.
              </notes>
            </value>
          </enum>
          <description>
            The desired setting for the camera device's auto-exposure algorithm's antibanding
            compensation.
          </description>
          <range>
            camera.ae.availableAntibandingModes
          </range>
          <details>
            Some kinds of lighting fixtures, such as some fluorescent lights, flicker at the rate
            of the power supply frequency (60Hz or 50Hz, depending on country). While this is
            typically not noticeable to a person, it can be visible to a camera device. If a
            camera sets its exposure time to the wrong value, the flicker may become visible in
            the viewfinder as flicker or in a final captured image, as a set of
            variable-brightness bands across the image.

            Therefore, the auto-exposure routines of camera devices include antibanding routines
            that ensure that the chosen exposure value will not cause such banding. The choice of
            exposure time depends on the rate of flicker, which the camera device can detect
            automatically, or the expected rate can be selected by the application using this
            control.

            A given camera device may not support all of the possible options for the antibanding
            mode. The camera.ae.availableAntibandingModes key contains the available modes
            for a given camera device.

            AUTO mode is the default if it is available on given camera device. When AUTO mode is
            not available, the default will be either 50HZ or 60HZ, and both 50HZ and 60HZ will
            be available.

            If manual exposure control is enabled (by setting camera.ae.mode or camera.control.mode
            to OFF), then this setting has no effect, and the application must ensure it selects
            exposure times that do not cause banding issues. The camera.statistics.sceneFlicker
            key can assist the application in this.
          </details>
        </entry>

        <entry name="compensation" type="int32" visibility="public">
          <description>Adjustment to auto-exposure (AE) target image brightness.</description>
          <units>Compensation steps</units>
          <range>camera.ae.compensationRange</range>
          <details>
            The adjustment is measured as a count of steps, with the step size defined by
            camera.ae.compensationStep and the allowed range by camera.ae.compensationRange.

            For example, if the exposure value (EV) step is 0.333, '6' will mean an exposure
            compensation of +2 EV; -3 will mean an exposure compensation of -1 EV. One EV
            represents a doubling of image brightness. Note that this control will only be
            effective if camera.ae.mode `!=` OFF. This control will take effect even when
            camera.ae.lock `== true`.

            In the event of exposure compensation value being changed, camera device may take
            several frames to reach the newly requested exposure target. During that time,
            camera.ae.state field will be in the SEARCHING state. Once the new exposure
            target is reached, camera.ae.state will change from SEARCHING to either
            CONVERGED, LOCKED (if AE lock is enabled), or FLASH_REQUIRED (if the scene is too
            dark for still capture).
          </details>
        </entry>

        <entry name="targetFpsRange" type="float" visibility="public"
               container="array" typedef="rangeInt">
          <array>
            <size>2</size>
          </array>
          <description>
            Range over which the auto-exposure routine can adjust the capture frame rate to
            maintain good exposure.
          </description>
          <units>Frames per second (FPS)</units>
          <range>Any of the entries in camera.ae.availableTargetFpsRanges</range>
          <details>
            Only constrains auto-exposure (AE) algorithm, not manual control of
            camera.sensor.exposureTime and camera.sensor.frameDuration.
          </details>
        </entry>

        <entry name="precaptureTrigger" type="byte" visibility="public" enum="true">
          <enum>
            <value>IDLE
              <notes>The trigger is idle.</notes>
            </value>
            <value>START
              <notes>The precapture metering sequence will be started
              by the camera device.

              The exact effect of the precapture trigger depends on
              the current AE mode and state.</notes>
            </value>
          </enum>
          <description>
            Whether the camera device will trigger a precapture metering sequence when it
            processes this request.
          </description>
          <details>
            This entry is normally set to IDLE, or is not included at all in the request settings.
            When included and set to START, the camera device will trigger the auto-exposure (AE)
            precapture metering sequence.

            The precapture sequence should be triggered before starting a high-quality still
            capture for final metering decisions to be made, and for firing pre-capture flash
            pulses to estimate scene brightness and required final capture flash power, when
            the flash is enabled.

            Normally, this entry should be set to START for only a single request, and the
            application should wait until the sequence completes before starting a new one.

            When a precapture metering sequence is finished, the camera device may lock the
            auto-exposure routine internally to be able to accurately expose the subsequent still
            capture image. For this case, the AE
            may not resume normal scan if no subsequent still capture is submitted. To ensure that
            the AE routine restarts normal scan, the application should submit a request with
            `camera.ae.lock == true`, followed by a request with `camera.ae.lock == false`, if the
            application decides not to submit a still capture request after the precapture sequence
            completes.

            The exact effect of auto-exposure (AE) precapture trigger depends on the current AE
            mode and state; see camera.ae.state for AE precapture state transition details.

            On LEGACY-level devices, the precapture trigger is not supported; capturing a
            high-resolution JPEG image will automatically trigger a precapture sequence before the
            high-resolution capture, including potentially firing a pre-capture flash.
          </details>
          <tag id="FUTURE" />
        </entry>
      </controls>

      <dynamic>
        <entry name="state" type="byte" visibility="public" enum="true" hwlevel="limited">
          <enum>
            <value>INACTIVE
              <notes>AE is off or recently reset.

              When a camera device is opened, it starts in this state. This is a transient state,
              the camera device may skip reporting this state in capture result.</notes>
            </value>
            <value>SEARCHING
              <notes>AE doesn't yet have a good set of control values for the current scene.

              This is a transient state, the camera device may skip reporting this state in capture
              result.</notes>
            </value>
            <value>CONVERGED
              <notes>AE has a good set of control values for the current scene.</notes>
            </value>
            <value>LOCKED
              <notes>AE has been locked.</notes>
            </value>
            <value>FLASH_REQUIRED
              <notes>AE has a good set of control values, but flash needs to be fired for good
              quality still capture.</notes>
            </value>
            <value>PRECAPTURE
              <notes>AE has been asked to do a precapture sequence and is currently executing it.

              Precapture can be triggered through setting camera.ae.precaptureTrigger to START.

              Once PRECAPTURE completes, AE will transition to CONVERGED or FLASH_REQUIRED as
              appropriate. This is a transient state, the camera device may skip reporting this
              state in capture result.</notes>
            </value>
          </enum>
          <description>Current state of the auto-exposure (AE) algorithm.</description>
          <details>
          Switching between or enabling AE modes (camera.ae.mode) always
          resets the AE state to INACTIVE. Similarly, switching between camera.control.mode,
          or camera.control.sceneMode if `camera.control.mode == USE_SCENE_MODE` resets all
          the algorithm states to INACTIVE.

          The camera device can do several state transitions between two results, if it is
          allowed by the state transition table. For example: INACTIVE may never actually be
          seen in a result.

          The state in the result is the state for this image (in sync with this image): if
          AE state becomes CONVERGED, then the image data associated with this result should
          be good to use.

          Below are state transition tables for different AE modes.

            State       | Transition Cause | New State | Notes
          :------------:|:----------------:|:---------:|:-----------------------:
          INACTIVE      |                  | INACTIVE  | Camera device auto exposure algorithm is disabled

          When camera.ae.mode is AE_MODE_ON_*:

            State        | Transition Cause                             | New State      | Notes
          :-------------:|:--------------------------------------------:|:--------------:|:-----------------:
          INACTIVE       | Camera device initiates AE scan              | SEARCHING      | Values changing
          INACTIVE       | camera.ae.lock is ON                         | LOCKED         | Values locked
          SEARCHING      | Camera device finishes AE scan               | CONVERGED      | Good values, not changing
          SEARCHING      | Camera device finishes AE scan               | FLASH_REQUIRED | Converged but too dark w/o flash
          SEARCHING      | camera.ae.lock is ON                         | LOCKED         | Values locked
          CONVERGED      | Camera device initiates AE scan              | SEARCHING      | Values changing
          CONVERGED      | camera.ae.lock is ON                         | LOCKED         | Values locked
          FLASH_REQUIRED | Camera device initiates AE scan              | SEARCHING      | Values changing
          FLASH_REQUIRED | camera.ae.lock is ON                         | LOCKED         | Values locked
          LOCKED         | camera.ae.lock is OFF                        | SEARCHING      | Values not good after unlock
          LOCKED         | camera.ae.lock is OFF                        | CONVERGED      | Values good after unlock
          LOCKED         | camera.ae.lock is OFF                        | FLASH_REQUIRED | Exposure good, but too dark
          PRECAPTURE     | Sequence done. camera.ae.lock is OFF         | CONVERGED      | Ready for high-quality capture
          PRECAPTURE     | Sequence done. camera.ae.lock is ON          | LOCKED         | Ready for high-quality capture
          Any state      | camera.ae.precaptureTrigger is START         | PRECAPTURE     | Start AE precapture metering sequence

          For the above table, the camera device may skip reporting any state changes that happen
          without application intervention (i.e. mode switch, trigger, locking). Any state that
          can be skipped in that manner is called a transient state.

          For example, for above AE modes (AE_MODE_ON_*), in addition to the state transitions
          listed in above table, it is also legal for the camera device to skip one or more
          transient states between two results. See below table for examples:

            State        | Transition Cause                                            | New State      | Notes
          :-------------:|:-----------------------------------------------------------:|:--------------:|:-----------------:
          INACTIVE       | Camera device finished AE scan                              | CONVERGED      | Values are already good, transient states are skipped by camera device.
          Any state      | camera.ae.precaptureTrigger is START, sequence done         | FLASH_REQUIRED | Converged but too dark w/o flash after a precapture sequence, transient states are skipped by camera device.
          Any state      | camera.ae.precaptureTrigger is START, sequence done         | CONVERGED      | Converged after a precapture sequence, transient states are skipped by camera device.
          CONVERGED      | Camera device finished AE scan                              | FLASH_REQUIRED | Converged but too dark w/o flash after a new scan, transient states are skipped by camera device.
          FLASH_REQUIRED | Camera device finished AE scan                              | CONVERGED      | Converged after a new scan, transient states are skipped by camera device.
          </details>
          <tag id="FUTURE" />
        </entry>
      </dynamic>

      <static>
        <entry name="availableModes" type="byte" visibility="public"
               type_notes="list of enums" container="array" typedef="enumList">
          <array>
            <size>n</size>
          </array>
          <description>
            List of auto-exposure modes for camera.ae.mode that are supported by this camera
            device.
          </description>
          <range>Any value listed in camera.ae.mode</range>
          <details>
            Not all the auto-exposure modes may be supported by a given camera device,
            especially if no flash unit is available. This entry lists the valid modes for
            camera.ae.mode for this camera device.

            All camera devices support ON, and all camera devices with flash units support
            ON_AUTO_FLASH and ON_ALWAYS_FLASH.

            FULL mode camera devices always support OFF mode, which enables application control of
            camera exposure time, sensitivity, and frame duration.
          </details>
        </entry>

        <entry name="availableAntibandingModes" type="byte" visibility="public"
               type_notes="list of enums" container="array" typedef="enumList">
          <array>
            <size>n</size>
          </array>
          <description>
            List of auto-exposure antibanding modes for camera.ae.antibandingMode that are
            supported by this camera device.
          </description>
          <range>Any value listed in camera.ae.antibandingMode</range>
          <details>
            Not all of the auto-exposure anti-banding modes may be supported by a given camera
            device. This field lists the valid anti-banding modes that the application may
            request for this camera device with the camera.ae.antibandingMode control.
          </details>
        </entry>
	
        <entry name="compensationStep" type="rational" visibility="public">
          <description>Smallest step by which the exposure compensation can be changed.</description>
          <units>Exposure Value (EV)</units>
          <details>
            This is the unit for camera.ae.compensation. For example, if this key has
            a value of `1/2`, then a setting of `-2` for camera.ae.compensation means
            that the target EV offset for the auto-exposure routine is -1 EV.

            One unit of EV compensation changes the brightness of the captured image by a factor
            of two. +1 EV doubles the image brightness, while -1 EV halves the image brightness.
          </details>
        </entry>

        <entry name="compensationRange" type="int32" visibility="public" container="array">
          <array>
            <size>2</size>
          </array>
          <description>Supported maximum and minimum exposure compensation values.</description>
          <details>
            Range [0,0] indicates that exposure compensation is not supported.

            Range must follow below requirements if exposure compensation is supported:

            `Min.exposure compensation * camera.ae.compensationStep &lt;= -2 EV`

            `Max.exposure compensation * camera.ae.compensationStep &gt;= 2 EV`
          </details>
        </entry>

        <entry name="availableTargetFpsRanges" type="float" visibility="public"
               type_notes="list of pairs of frame rates" container="array" typedef="rangeFloat">
          <array>
            <size>2</size>
            <size>n</size>
          </array>
          <description>
            List of frame rate ranges for camera.ae.targetFpsRange supported by this camera device.
          </description>
          <units>Frames per second (FPS)</units>
          <details>
            For devices at the LIMITED level or above, this list will include at least (30, 30)
            for constant-framerate recording.
          </details>
        </entry>
        <entry name="lockAvailable" type="byte" visibility="public" enum="true"
               typedef="boolean" hwlevel="legacy">
          <enum>
            <value>FALSE</value>
            <value>TRUE</value>
          </enum>
          <description>Whether the camera device supports android.control.aeLock</description>
          <details>
              Devices with MANUAL_SENSOR capability or BURST_CAPTURE capability will always
              list `ON`. This includes FULL devices.
          </details>
          <tag id="BC"/>
        </entry>
      </static>

    </section>

    <section name="awb">
      <controls>
        <entry name="mode" type="byte" visibility="public" enum="true">
          <enum>
            <value>AUTO
              <notes>
                The camera device's auto white balance routine is active.
              </notes>
            </value>
            <value>INCANDESCENT
              <notes>
                The camera device's auto-white balance routine is disabled; the camera device uses
                incandescent light as the assumed scene illumination for white balance.

                While the exact white balance transforms are up to the camera device, they will
                approximately match the CIE standard illuminant A.
              </notes>
            </value>
            <value>FLUORESCENT
              <notes>
                The camera device's auto-white balance routine is disabled; the camera device uses
                fluorescent light as the assumed scene illumination for white balance.

                While the exact white balance transforms are up to the camera device, they will
                approximately match the CIE standard illuminant F2.
              </notes>
            </value>
            <value>DAYLIGHT
              <notes>
                The camera device's auto-white balance routine is disabled; the camera device uses
                daylight light as the assumed scene illumination for white balance.

                While the exact white balance transforms are up to the camera device, they will
                approximately match the CIE standard illuminant D65.
              </notes>
            </value>
            <value>FULL_OVERCAST
              <notes>
                The camera device's auto-white balance routine is disabled; the camera device uses
                full overcase daylight light as the assumed scene illumination for white balance.
              </notes>
            </value>
            <value>PARTLY_OVERCAST
              <notes>
                The camera device's auto-white balance routine is disabled; the camera device uses
                partly overcase daylight light as the assumed scene illumination for white balance.
              </notes>
            </value>
            <value>SUNSET
              <notes>
                The camera device's auto-white balance routine is disabled; the camera device uses
                sunset light as the assumed scene illumination for white balance.
              </notes>
            </value>
            <value>VIDEO_CONFERENCE
              <notes>
                The camera device's auto-white balance routine is disabled; the camera device uses
                video conference light as the assumed scene illumination for white balance.
              </notes>
            </value>
            <value>MANUAL_CCT_RANGE
              <notes>
                The camera device's auto white balance routine is disabled.
                The white balance cct range application specified will be used by the camera device.
              </notes>
            </value>
            <value>MANUAL_WHITE_POINT
              <notes>
                The camera device's auto white balance routine is disabled.
                The white balance is based on the white area user specifed.
              </notes>
            </value>
            <value>MANUAL_GAIN
              <notes>
                The camera device's auto white balance routine is disabled.
                The white balance gains application specified will be used by the camera device.
              </notes>
            </value>
            <value>MANUAL_COLOR_TRANSFORM
              <notes>
                Use camera.awb.colorTransform and camera.awb.colorGains to do color conversion.
              </notes>
            </value>
          </enum>
          <description>
            Whether auto-white balance (AWB) is currently setting the color transform fields, and
            what its illumination target is.
          </description>
          <range>camera.awb.availableModes</range>
          <details>
            This control is only effective if camera.control.mode is AUTO.

            When set to the AUTO mode, the camera device's auto-white balance routine is enabled,
            overriding the application's selected camera.awb.colorTransform, camera.awb.colorGains.
            Note that when camera.ae.mode is OFF, the behavior of AWB is device dependent. It is
            recommened to also set AWB mode to OFF or lock AWB by using camera.awb.lock before
            setting AE mode to OFF.

            When set to the MANUAL_* mode, the camera device's auto-white balance routine is
            disabled. The application manually controls the white balance.

            When set to any other modes, the camera device's auto-white balance routine is
            disabled. The camera device uses each particular illumination target for white
            balance adjustment. The application's values are ignored.
          </details>
        </entry>

        <entry name="colorTransform" type="float" visibility="public"
               type_notes="3x3 float matrix in row-major order"
               container="array" typedef="colorSpaceTransform">
          <array>
            <size>3</size>
            <size>3</size>
          </array>
          <description>A color transform matrix to use to transform
          from sensor RGB color space to output linear sRGB color space.
          </description>
          <units>Unitless scale factors</units>
          <details>This matrix is either set by the camera device when the request
          camera.awb.mode is not MANUAL_COLOR_TRANSFORM, or directly by the
          application in the request when the camera.awb.mode is
          MANUAL_COLOR_TRANSFORM.

          In the latter case, the camera device may round the matrix to account
          for precision issues; the final rounded matrix should be reported back
          in this matrix result metadata. The transform should keep the magnitude
          of the output color values within `[0, 1.0]` (assuming input color
          values is within the normalized range `[0, 1.0]`), or clipping may occur.
          </details>
        </entry>

        <entry name="colorGains" type="float" visibility="public"
               type_notes="A 1D array of floats for 4 color channel gains"
               container="array" typedef="rggbChannelVector">
          <array>
            <size>4</size>
          </array>
          <description>Gains applying to Bayer raw color channels for
          white-balance.</description>
          <units>Unitless gain factors</units>
          <details>
            These per-channel gains are either set by the camera device when the
            request camera.awb.mode is not MANUAL_COLOR_TRANSFORM, or directly by
            the application in the request when the camera.awb.mode is
            MANUAL_COLOR_TRANSFORM.

            The gains in the result metadata are the gains actually
            applied by the camera device to the current frame.

            The 4-channel white-balance gains are defined in
            the order of `[R G_even G_odd B]`, where `G_even` is the gain
            for green pixels on even rows of the output, and `G_odd`
            is the gain for green pixels on the odd rows.
          </details>
        </entry>

        <entry name="lock" type="byte" visibility="public" enum="true" typedef="boolean">
          <enum>
            <value>OFF
              <notes>Auto-white balance lock is disabled; the AWB algorithm is free to update its
              parameters if in AUTO mode.</notes>
            </value>
            <value>ON
              <notes>Auto-white balance lock is enabled; the AWB algorithm will not update its
              parameters while the lock is active.</notes>
            </value>
          </enum>
          <description>
            Whether auto-white balance (AWB) is currently locked to its latest calculated values.
          </description>
          <details>
            When set to `true` (ON), the AWB algorithm is locked to its latest parameters, and
            will not change color balance settings until the lock is set to `false` (OFF).

            Since the camera device has a pipeline of in-flight requests, the settings that get
            locked do not necessarily correspond to the settings that were present in the latest
            capture result received from the camera device, since additional captures and AWB
            updates may have occurred even before the result was sent out. If an application is
            switching between automatic and manual control and wishes to eliminate any flicker
            during the switch, the following procedure is recommended:

            1. Starting in auto-AWB mode:
            2. Lock AWB
            3. Wait for the first result to be output that has the AWB locked
            4. Copy AWB settings from that result into a request, set the request to manual AWB
            5. Submit the capture request, proceed to run manual AWB as desired.

            Note that AWB lock is only meaningful when camera.awb.mode is in the AUTO mode; in
            other modes, AWB is already fixed to a specific setting.

            Some LEGACY devices may not support ON; the value is then overridden to OFF.
          </details>
          <tag id="FUTURE" />
        </entry>

        <entry name="regions" type="int32" visibility="public"
               optional="true" container="array" typedef="meteringRectangle">
          <array>
            <size>5</size>
            <size>area_count</size>
          </array>
          <description>
            List of metering areas to use for auto-white-balance illuminant estimation.
          </description>
          <units>Pixel coordinates within camera.sensor.info.activeArraySize</units>
          <range>Coordinates must be between `[(0,0), (width, height))` of
          camera.sensor.info.activeArraySize</range>
          <details>
            Not available if AWB value of camera.control.maxRegions is 0. Otherwise will always be present.

            The maximum number of regions supported by the device is determined by the AWB value of
            camera.control.maxRegions.

            The coordinate system is based on the active pixel array, with (0,0) being the top-left
            pixel in the active pixel array, and (camera.sensor.info.activeArraySize.width - 1,
            camera.sensor.info.activeArraySize.height - 1) being the bottom-right pixel in the
            active pixel array.

            The weight must range from 0 to 1000, and represents a weight for every pixel in the
            area. This means that a large metering area with the same weight as a smaller area will
            have more effect in the metering result. Metering areas can partially overlap and the
            camera device will add the weights in the overlap region.

            The weights are relative to weights of other white balance metering regions, so if
            only one region is used, all non-zero weights will have the same effect. A region with
            0 weight is ignored.

            If all regions have 0 weight, then no specific metering area needs to be used by the
            camera device.

            If the metering region is outside the used camera.scaler.cropRegion returned in
            capture result metadata, the camera device will ignore the sections outside the crop
            region and output only the intersection rectangle as the metering region in the result
            metadata. If the region is entirely outside the crop region, it will be ignored and
            not reported in the result metadata.

            Every metering rectangle is defined as (left, top, right, bottom, weight), inclusive
            on left and top, but exclusive on right and bottom.
          </details>
        </entry>

        <entry name="cctRange" type="int32" visibility="public" container="array">
          <array>
            <size>2</size>
          </array>
          <description>
            Manually specify min and max cct.
            Only available what awb mode set to MANUAL_CCT_RANGE.
          </description>
        </entry>

        <entry name="gains" type="int32" visibility="public" container="array">
          <array>
            <size>3</size>
          </array>
          <description>
            Manually specify R-Gain, G-Gain, and B-Gain.
            Only available what awb mode set to MANUAL_GAIN.
          </description>
        </entry>

        <entry name="gainShift" type="int32" visibility="public" container="array">
          <array>
            <size>3</size>
          </array>
          <description>
            Adjust R-Gain, G-Gain, and B-Gain base on awb result or pre-defined awb mode.
            No available when awb mode set to MANUAL_GAIN.
          </description>
        </entry>

        <entry name="whitePoint" type="int32" visibility="public" container="array">
          <array>
            <size>2</size>
          </array>
          <description>White point to use for auto white balance adjustment.</description>
        </entry>

        <entry name="convergeSpeed" type="byte" visibility="public" enum="true">
          <enum>
            <value>NORMAL
              <notes>The AWB converge speed is normal.</notes>
            </value>
            <value>MID
              <notes>The AWB converge speed is mid.</notes>
            </value>
            <value>LOW
              <notes>The AWB converge speed is low.</notes>
            </value>
          </enum>
          <description>Control converge speed of AWB.</description>
        </entry>

        <entry name="convergeSpeedMode" type="byte" visibility="public" enum="true">
          <enum>
            <value>HAL
              <notes>Use HAL implement to control AWB converge speed</notes>
            </value>
            <value>AIQ
              <notes>Use AIQ implement to control AWB converge speed</notes>
            </value>
          </enum>
          <description>Control AWB converge speed mode</description>
        </entry>
      </controls>

      <dynamic>
        <entry name="state" type="byte" visibility="public" enum="true">
          <enum>
            <value>INACTIVE
              <notes>
                AWB is not in auto mode, or has not yet started metering.

                When a camera device is opened, it starts in this state. This is a transient state,
                the camera device may skip reporting this state in capture result.
              </notes>
            </value>
            <value>SEARCHING
              <notes>
                AWB doesn't yet have a good set of control values for the current scene.

                This is a transient state, the camera device may skip reporting this state in
                capture result.
              </notes>
            </value>
            <value>CONVERGED
              <notes>AWB has a good set of control values for the current scene.</notes>
            </value>
            <value>LOCKED
              <notes>AWB has been locked.</notes>
            </value>
          </enum>
          <description>Current state of auto-white balance (AWB) algorithm.</description>
          <details>
            Switching between or enabling AWB modes (camera.awb.mode) always resets the AWB state
            to INACTIVE. Similarly, switching between camera.control.mode, or
            camera.control.sceneMode if `camera.control.mode == USE_SCENE_MODE` resets all the
            algorithm states to INACTIVE.

            The camera device can do several state transitions between two results, if it is
            allowed by the state transition table. So INACTIVE may never actually be seen in
            a result.

            The state in the result is the state for this image (in sync with this image): if
            AWB state becomes CONVERGED, then the image data associated with this result should
            be good to use.

            Below are state transition tables for different AWB modes.

            When `camera.awb.mode != AWB_MODE_AUTO`:

              State       | Transition Cause | New State | Notes
            :------------:|:----------------:|:---------:|:-----------------------:
            INACTIVE      |                  |INACTIVE   |Camera device auto white balance algorithm is disabled

            When camera.awb.mode is AWB_MODE_AUTO:

              State        | Transition Cause                 | New State     | Notes
            :-------------:|:--------------------------------:|:-------------:|:-----------------:
            INACTIVE       | Camera device initiates AWB scan | SEARCHING     | Values changing
            INACTIVE       | camera.awb.lock is ON            | LOCKED        | Values locked
            SEARCHING      | Camera device finishes AWB scan  | CONVERGED     | Good values, not changing
            SEARCHING      | camera.awb.lock is ON            | LOCKED        | Values locked
            CONVERGED      | Camera device initiates AWB scan | SEARCHING     | Values changing
            CONVERGED      | camera.awb.lock is ON            | LOCKED        | Values locked
            LOCKED         | camera.awb.lock is OFF           | SEARCHING     | Values not good after unlock

            For the above table, the camera device may skip reporting any state changes that happen
            without application intervention (i.e. mode switch, trigger, locking). Any state that
            can be skipped in that manner is called a transient state.

            For example, for this AWB mode (AWB_MODE_AUTO), in addition to the state transitions
            listed in above table, it is also legal for the camera device to skip one or more
            transient states between two results. See below table for examples:

              State        | Transition Cause                 | New State     | Notes
            :-------------:|:--------------------------------:|:-------------:|:-----------------:
            INACTIVE       | Camera device finished AWB scan  | CONVERGED     | Values are already good, transient states are skipped by camera device.
            LOCKED         | camera.awb.lock is OFF           | CONVERGED     | Values good after unlock, transient states are skipped by camera device.
          </details>
          <tag id="FUTURE" />
        </entry>

        <entry name="result" type="byte" visibility="public" container="array">
          <array>
            <size>n</size>
          </array>
          <description>
            To override the awb result gotten from 3A.
          </description>
        </entry>
      </dynamic>

      <static>
        <entry name="availableModes" type="byte" visibility="public" type_notes="List of enums"
               container="array" typedef="enumList">
          <array>
            <size>n</size>
          </array>
          <description>
            List of auto-white-balance modes for camera.awb.mode that are supported by this
            camera device.
          </description>
          <range>Any value listed in camera.awb.mode</range>
          <details>
            Not all the auto-white-balance modes may be supported by a given camera device. This
            entry lists the valid modes for camera.awb.mode for this camera device.

            All camera devices will support ON mode.

            Camera devices that support the MANUAL_POST_PROCESSING capability will always support
            OFF mode, which enables application control of white balance, by using
            camera.awb.colorTransform and camera.awb.colorGains.
            This includes all FULL mode camera devices.
          </details>
        </entry>
        <entry name="lockAvailable" type="byte" visibility="public" enum="true"
               typedef="boolean" hwlevel="legacy">
          <enum>
            <value>FALSE</value>
            <value>TRUE</value>
          </enum>
          <description>Whether the camera device supports android.control.awbLock</description>
          <details>
              Devices with MANUAL_POST_PROCESSING capability or BURST_CAPTURE capability will
              always list `true`. This includes FULL devices.
          </details>
          <tag id="BC"/>
        </entry>
      </static>
    </section>

    <section name="af">
      <controls>
        <entry name="mode" type="byte" visibility="public" enum="true"
               hwlevel="legacy">
          <enum>
            <value>OFF
            <notes>The auto-focus routine does not control the lens;
            camera.lens.focusDistance is controlled by the
            application.</notes></value>
            <value>AUTO
            <notes>Basic automatic focus mode.

            In this mode, the lens does not move unless
            the autofocus trigger action is called. When that trigger
            is activated, AF will transition to ACTIVE_SCAN, then to
            the outcome of the scan (FOCUSED or NOT_FOCUSED).

            Always supported if lens is not fixed focus.

            Use camera.lens.info.minimumFocusDistance to determine if lens
            is fixed-focus.

            Triggering AF_CANCEL resets the lens position to default,
            and sets the AF state to INACTIVE.</notes></value>
            <value>MACRO
            <notes>Close-up focusing mode.

            In this mode, the lens does not move unless the
            autofocus trigger action is called. When that trigger is
            activated, AF will transition to ACTIVE_SCAN, then to
            the outcome of the scan (FOCUSED or NOT_FOCUSED). This
            mode is optimized for focusing on objects very close to
            the camera.

            When that trigger is activated, AF will transition to
            ACTIVE_SCAN, then to the outcome of the scan (FOCUSED or
            NOT_FOCUSED). Triggering cancel AF resets the lens
            position to default, and sets the AF state to
            INACTIVE.</notes></value>
            <value>CONTINUOUS_VIDEO
            <notes>In this mode, the AF algorithm modifies the lens
            position continually to attempt to provide a
            constantly-in-focus image stream.

            The focusing behavior should be suitable for good quality
            video recording; typically this means slower focus
            movement and no overshoots. When the AF trigger is not
            involved, the AF algorithm should start in INACTIVE state,
            and then transition into PASSIVE_SCAN and PASSIVE_FOCUSED
            states as appropriate. When the AF trigger is activated,
            the algorithm should immediately transition into
            AF_FOCUSED or AF_NOT_FOCUSED as appropriate, and lock the
            lens position until a cancel AF trigger is received.

            Once cancel is received, the algorithm should transition
            back to INACTIVE and resume passive scan. Note that this
            behavior is not identical to CONTINUOUS_PICTURE, since an
            ongoing PASSIVE_SCAN must immediately be
            canceled.</notes></value>
            <value>CONTINUOUS_PICTURE
            <notes>In this mode, the AF algorithm modifies the lens
            position continually to attempt to provide a
            constantly-in-focus image stream.

            The focusing behavior should be suitable for still image
            capture; typically this means focusing as fast as
            possible. When the AF trigger is not involved, the AF
            algorithm should start in INACTIVE state, and then
            transition into PASSIVE_SCAN and PASSIVE_FOCUSED states as
            appropriate as it attempts to maintain focus. When the AF
            trigger is activated, the algorithm should finish its
            PASSIVE_SCAN if active, and then transition into
            AF_FOCUSED or AF_NOT_FOCUSED as appropriate, and lock the
            lens position until a cancel AF trigger is received.

            When the AF cancel trigger is activated, the algorithm
            should transition back to INACTIVE and then act as if it
            has just been started.</notes></value>
            <value>EDOF
            <notes>Extended depth of field (digital focus) mode.

            The camera device will produce images with an extended
            depth of field automatically; no special focusing
            operations need to be done before taking a picture.

            AF triggers are ignored, and the AF state will always be
            INACTIVE.</notes></value>
          </enum>
          <description>Whether auto-focus (AF) is currently enabled, and what
          mode it is set to.</description>
          <range>camera.af.availableModes</range>
          <details>Only effective if camera.control.mode = AUTO and the lens is not fixed focus
          (i.e. `camera.lens.info.minimumFocusDistance &gt; 0`). Also note that
          when camera.ae.mode is OFF, the behavior of AF is device
          dependent. It is recommended to lock AF by using camera.af.trigger before
          setting camera.ae.mode to OFF, or set AF mode to OFF when AE is OFF.

          If the lens is controlled by the camera device auto-focus algorithm,
          the camera device will report the current AF status in camera.af.state
          in result metadata.</details>
          <hal_details>
          When afMode is AUTO or MACRO, the lens must not move until an AF trigger is sent in a
          request (camera.af.trigger `==` START). After an AF trigger, the afState will end
          up with either FOCUSED_LOCKED or NOT_FOCUSED_LOCKED state (see
          camera.af.state for detailed state transitions), which indicates that the lens is
          locked and will not move. If camera movement (e.g. tilting camera) causes the lens to move
          after the lens is locked, the HAL must compensate this movement appropriately such that
          the same focal plane remains in focus.

          When afMode is one of the continuous auto focus modes, the HAL is free to start a AF
          scan whenever it's not locked. When the lens is locked after an AF trigger
          (see camera.af.state for detailed state transitions), the HAL should maintain the
          same lock behavior as above.

          When afMode is OFF, the application controls focus manually. The accuracy of the
          focus distance control depends on the camera.lens.info.focusDistanceCalibration.
          However, the lens must not move regardless of the camera movement for any focus distance
          manual control.

          To put this in concrete terms, if the camera has lens elements which may move based on
          camera orientation or motion (e.g. due to gravity), then the HAL must drive the lens to
          remain in a fixed position invariant to the camera's orientation or motion, for example,
          by using accelerometer measurements in the lens control logic. This is a typical issue
          that will arise on camera modules with open-loop VCMs.
          </hal_details>
          <tag id="BC" />
        </entry>
        <entry name="regions" type="int32" visibility="public"
               optional="true" container="array" typedef="meteringRectangle">
          <array>
            <size>5</size>
            <size>area_count</size>
          </array>
          <description>List of metering areas to use for auto-focus.</description>
          <units>Pixel coordinates within camera.sensor.info.activeArraySize</units>
          <range>Coordinates must be between `[(0,0), (width, height))` of
          camera.sensor.info.activeArraySize</range>
          <details>
              Not available if AF value of camera.control.maxRegions is 0.
              Otherwise will always be present.

              The maximum number of focus areas supported by the device is determined by the AF value
              of camera.control.maxRegions.

              The coordinate system is based on the active pixel array,
              with (0,0) being the top-left pixel in the active pixel array, and
              (camera.sensor.info.activeArraySize.width - 1,
              camera.sensor.info.activeArraySize.height - 1) being the
              bottom-right pixel in the active pixel array.

              The weight must be within `[0, 1000]`, and represents a weight
              for every pixel in the area. This means that a large metering area
              with the same weight as a smaller area will have more effect in
              the metering result. Metering areas can partially overlap and the
              camera device will add the weights in the overlap region.

              The weights are relative to weights of other metering regions, so if only one region
              is used, all non-zero weights will have the same effect. A region with 0 weight is
              ignored.

              If all regions have 0 weight, then no specific metering area needs to be used by the
              camera device.

              If the metering region is outside the used camera.scaler.cropRegion returned in
              capture result metadata, the camera device will ignore the sections outside the crop
              region and output only the intersection rectangle as the metering region in the result
              metadata. If the region is entirely outside the crop region, it will be ignored and
              not reported in the result metadata.
          </details>
          <hal_details>
              The HAL level representation of MeteringRectangle[] is a
              int[5 * area_count].
              Every five elements represent a metering region of
              (xmin, ymin, xmax, ymax, weight).
              The rectangle is defined to be inclusive on xmin and ymin, but
              exclusive on xmax and ymax.
          </hal_details>
          <tag id="BC" />
        </entry>
        <entry name="trigger" type="byte" visibility="public" enum="true"
               hwlevel="legacy">
          <enum>
            <value>IDLE
              <notes>The trigger is idle.</notes>
            </value>
            <value>START
              <notes>Autofocus will trigger now.</notes>
            </value>
            <value>CANCEL
              <notes>Autofocus will return to its initial
              state, and cancel any currently active trigger.</notes>
            </value>
          </enum>
          <description>
          Whether the camera device will trigger autofocus for this request.
          </description>
          <details>This entry is normally set to IDLE, or is not
          included at all in the request settings.

          When included and set to START, the camera device will trigger the
          autofocus algorithm. If autofocus is disabled, this trigger has no effect.

          When set to CANCEL, the camera device will cancel any active trigger,
          and return to its initial AF state.

          Generally, applications should set this entry to START or CANCEL for only a
          single capture, and then return it to IDLE (or not set at all). Specifying
          START for multiple captures in a row means restarting the AF operation over
          and over again.

          See camera.af.state for what the trigger means for each AF mode.
          </details>
          <tag id="BC" />
        </entry>
      </controls>
      <static>
        <entry name="availableModes" type="byte" visibility="public"
               type_notes="List of enums" container="array" typedef="enumList"
               hwlevel="legacy">
          <array>
            <size>n</size>
          </array>
          <description>
          List of auto-focus (AF) modes for camera.af.mode that are
          supported by this camera device.
          </description>
          <range>Any value listed in camera.af.mode</range>
          <details>
          Not all the auto-focus modes may be supported by a
          given camera device. This entry lists the valid modes for
          camera.af.mode for this camera device.

          All LIMITED and FULL mode camera devices will support OFF mode, and all
          camera devices with adjustable focuser units
          (`camera.lens.info.minimumFocusDistance &gt; 0`) will support AUTO mode.

          LEGACY devices will support OFF mode only if they support
          focusing to infinity (by also setting camera.lens.focusDistance to
          `0.0f`).
          </details>
          <tag id="BC" />
        </entry>
      </static>
      <dynamic>
        <clone entry="camera.af.mode" kind="controls">
        </clone>
        <clone entry="camera.af.regions" kind="controls">
        </clone>
        <clone entry="camera.af.trigger" kind="controls">
        </clone>
        <entry name="state" type="byte" visibility="public" enum="true"
               hwlevel="legacy">
          <enum>
            <value>INACTIVE
            <notes>AF is off or has not yet tried to scan/been asked
            to scan.

            When a camera device is opened, it starts in this
            state. This is a transient state, the camera device may
            skip reporting this state in capture
            result.</notes></value>
            <value>PASSIVE_SCAN
            <notes>AF is currently performing an AF scan initiated the
            camera device in a continuous autofocus mode.

            Only used by CONTINUOUS_* AF modes. This is a transient
            state, the camera device may skip reporting this state in
            capture result.</notes></value>
            <value>PASSIVE_FOCUSED
            <notes>AF currently believes it is in focus, but may
            restart scanning at any time.

            Only used by CONTINUOUS_* AF modes. This is a transient
            state, the camera device may skip reporting this state in
            capture result.</notes></value>
            <value>ACTIVE_SCAN
            <notes>AF is performing an AF scan because it was
            triggered by AF trigger.

            Only used by AUTO or MACRO AF modes. This is a transient
            state, the camera device may skip reporting this state in
            capture result.</notes></value>
            <value>FOCUSED_LOCKED
            <notes>AF believes it is focused correctly and has locked
            focus.

            This state is reached only after an explicit START AF trigger has been
            sent (camera.af.trigger), when good focus has been obtained.

            The lens will remain stationary until the AF mode (camera.af.mode) is changed or
            a new AF trigger is sent to the camera device (camera.af.trigger).
            </notes></value>
            <value>NOT_FOCUSED_LOCKED
            <notes>AF has failed to focus successfully and has locked
            focus.

            This state is reached only after an explicit START AF trigger has been
            sent (camera.af.trigger), when good focus cannot be obtained.

            The lens will remain stationary until the AF mode (camera.af.mode) is changed or
            a new AF trigger is sent to the camera device (camera.af.trigger).
            </notes></value>
            <value>PASSIVE_UNFOCUSED
            <notes>AF finished a passive scan without finding focus,
            and may restart scanning at any time.

            Only used by CONTINUOUS_* AF modes. This is a transient state, the camera
            device may skip reporting this state in capture result.

            LEGACY camera devices do not support this state. When a passive
            scan has finished, it will always go to PASSIVE_FOCUSED.
            </notes></value>
          </enum>
          <description>Current state of auto-focus (AF) algorithm.</description>
          <details>
          Switching between or enabling AF modes (camera.af.mode) always
          resets the AF state to INACTIVE. Similarly, switching between camera.control.mode,
          or camera.control.sceneMode if `camera.control.mode == USE_SCENE_MODE` resets all
          the algorithm states to INACTIVE.

          The camera device can do several state transitions between two results, if it is
          allowed by the state transition table. For example: INACTIVE may never actually be
          seen in a result.

          The state in the result is the state for this image (in sync with this image): if
          AF state becomes FOCUSED, then the image data associated with this result should
          be sharp.

          Below are state transition tables for different AF modes.

          When camera.af.mode is AF_MODE_OFF or AF_MODE_EDOF:

            State       | Transition Cause | New State | Notes
          :------------:|:----------------:|:---------:|:-----------:
          INACTIVE      |                  | INACTIVE  | Never changes

          When camera.af.mode is AF_MODE_AUTO or AF_MODE_MACRO:

            State            | Transition Cause | New State          | Notes
          :-----------------:|:----------------:|:------------------:|:--------------:
          INACTIVE           | AF_TRIGGER       | ACTIVE_SCAN        | Start AF sweep, Lens now moving
          ACTIVE_SCAN        | AF sweep done    | FOCUSED_LOCKED     | Focused, Lens now locked
          ACTIVE_SCAN        | AF sweep done    | NOT_FOCUSED_LOCKED | Not focused, Lens now locked
          ACTIVE_SCAN        | AF_CANCEL        | INACTIVE           | Cancel/reset AF, Lens now locked
          FOCUSED_LOCKED     | AF_CANCEL        | INACTIVE           | Cancel/reset AF
          FOCUSED_LOCKED     | AF_TRIGGER       | ACTIVE_SCAN        | Start new sweep, Lens now moving
          NOT_FOCUSED_LOCKED | AF_CANCEL        | INACTIVE           | Cancel/reset AF
          NOT_FOCUSED_LOCKED | AF_TRIGGER       | ACTIVE_SCAN        | Start new sweep, Lens now moving
          Any state          | Mode change      | INACTIVE           |

          For the above table, the camera device may skip reporting any state changes that happen
          without application intervention (i.e. mode switch, trigger, locking). Any state that
          can be skipped in that manner is called a transient state.

          For example, for these AF modes (AF_MODE_AUTO and AF_MODE_MACRO), in addition to the
          state transitions listed in above table, it is also legal for the camera device to skip
          one or more transient states between two results. See below table for examples:

            State            | Transition Cause | New State          | Notes
          :-----------------:|:----------------:|:------------------:|:--------------:
          INACTIVE           | AF_TRIGGER       | FOCUSED_LOCKED     | Focus is already good or good after a scan, lens is now locked.
          INACTIVE           | AF_TRIGGER       | NOT_FOCUSED_LOCKED | Focus failed after a scan, lens is now locked.
          FOCUSED_LOCKED     | AF_TRIGGER       | FOCUSED_LOCKED     | Focus is already good or good after a scan, lens is now locked.
          NOT_FOCUSED_LOCKED | AF_TRIGGER       | FOCUSED_LOCKED     | Focus is good after a scan, lens is not locked.


          When camera.af.mode is AF_MODE_CONTINUOUS_VIDEO:

            State            | Transition Cause                    | New State          | Notes
          :-----------------:|:-----------------------------------:|:------------------:|:--------------:
          INACTIVE           | Camera device initiates new scan    | PASSIVE_SCAN       | Start AF scan, Lens now moving
          INACTIVE           | AF_TRIGGER                          | NOT_FOCUSED_LOCKED | AF state query, Lens now locked
          PASSIVE_SCAN       | Camera device completes current scan| PASSIVE_FOCUSED    | End AF scan, Lens now locked
          PASSIVE_SCAN       | Camera device fails current scan    | PASSIVE_UNFOCUSED  | End AF scan, Lens now locked
          PASSIVE_SCAN       | AF_TRIGGER                          | FOCUSED_LOCKED     | Immediate transition, if focus is good. Lens now locked
          PASSIVE_SCAN       | AF_TRIGGER                          | NOT_FOCUSED_LOCKED | Immediate transition, if focus is bad. Lens now locked
          PASSIVE_SCAN       | AF_CANCEL                           | INACTIVE           | Reset lens position, Lens now locked
          PASSIVE_FOCUSED    | Camera device initiates new scan    | PASSIVE_SCAN       | Start AF scan, Lens now moving
          PASSIVE_UNFOCUSED  | Camera device initiates new scan    | PASSIVE_SCAN       | Start AF scan, Lens now moving
          PASSIVE_FOCUSED    | AF_TRIGGER                          | FOCUSED_LOCKED     | Immediate transition, lens now locked
          PASSIVE_UNFOCUSED  | AF_TRIGGER                          | NOT_FOCUSED_LOCKED | Immediate transition, lens now locked
          FOCUSED_LOCKED     | AF_TRIGGER                          | FOCUSED_LOCKED     | No effect
          FOCUSED_LOCKED     | AF_CANCEL                           | INACTIVE           | Restart AF scan
          NOT_FOCUSED_LOCKED | AF_TRIGGER                          | NOT_FOCUSED_LOCKED | No effect
          NOT_FOCUSED_LOCKED | AF_CANCEL                           | INACTIVE           | Restart AF scan

          When camera.af.mode is AF_MODE_CONTINUOUS_PICTURE:

            State            | Transition Cause                     | New State          | Notes
          :-----------------:|:------------------------------------:|:------------------:|:--------------:
          INACTIVE           | Camera device initiates new scan     | PASSIVE_SCAN       | Start AF scan, Lens now moving
          INACTIVE           | AF_TRIGGER                           | NOT_FOCUSED_LOCKED | AF state query, Lens now locked
          PASSIVE_SCAN       | Camera device completes current scan | PASSIVE_FOCUSED    | End AF scan, Lens now locked
          PASSIVE_SCAN       | Camera device fails current scan     | PASSIVE_UNFOCUSED  | End AF scan, Lens now locked
          PASSIVE_SCAN       | AF_TRIGGER                           | FOCUSED_LOCKED     | Eventual transition once the focus is good. Lens now locked
          PASSIVE_SCAN       | AF_TRIGGER                           | NOT_FOCUSED_LOCKED | Eventual transition if cannot find focus. Lens now locked
          PASSIVE_SCAN       | AF_CANCEL                            | INACTIVE           | Reset lens position, Lens now locked
          PASSIVE_FOCUSED    | Camera device initiates new scan     | PASSIVE_SCAN       | Start AF scan, Lens now moving
          PASSIVE_UNFOCUSED  | Camera device initiates new scan     | PASSIVE_SCAN       | Start AF scan, Lens now moving
          PASSIVE_FOCUSED    | AF_TRIGGER                           | FOCUSED_LOCKED     | Immediate trans. Lens now locked
          PASSIVE_UNFOCUSED  | AF_TRIGGER                           | NOT_FOCUSED_LOCKED | Immediate trans. Lens now locked
          FOCUSED_LOCKED     | AF_TRIGGER                           | FOCUSED_LOCKED     | No effect
          FOCUSED_LOCKED     | AF_CANCEL                            | INACTIVE           | Restart AF scan
          NOT_FOCUSED_LOCKED | AF_TRIGGER                           | NOT_FOCUSED_LOCKED | No effect
          NOT_FOCUSED_LOCKED | AF_CANCEL                            | INACTIVE           | Restart AF scan

          When switch between AF_MODE_CONTINUOUS_* (CAF modes) and AF_MODE_AUTO/AF_MODE_MACRO
          (AUTO modes), the initial INACTIVE or PASSIVE_SCAN states may be skipped by the
          camera device. When a trigger is included in a mode switch request, the trigger
          will be evaluated in the context of the new mode in the request.
          See below table for examples:

            State      | Transition Cause                       | New State                                | Notes
          :-----------:|:--------------------------------------:|:----------------------------------------:|:--------------:
          any state    | CAF-->AUTO mode switch                 | INACTIVE                                 | Mode switch without trigger, initial state must be INACTIVE
          any state    | CAF-->AUTO mode switch with AF_TRIGGER | trigger-reachable states from INACTIVE   | Mode switch with trigger, INACTIVE is skipped
          any state    | AUTO-->CAF mode switch                 | passively reachable states from INACTIVE | Mode switch without trigger, passive transient state is skipped
          </details>
          <tag id="FUTURE" />
        </entry>
      </dynamic>
    </section>

    <section name="control">
      <controls>
        <entry name="effectMode" type="byte" visibility="public" enum="true"
               hwlevel="legacy">
          <enum>
            <value>OFF
              <notes>
              No color effect will be applied.
              </notes>
            </value>
            <value optional="true">MONO
              <notes>
              A "monocolor" effect where the image is mapped into
              a single color.

              This will typically be grayscale.
              </notes>
            </value>
            <value optional="true">NEGATIVE
              <notes>
              A "photo-negative" effect where the image's colors
              are inverted.
              </notes>
            </value>
            <value optional="true">SOLARIZE
              <notes>
              A "solarisation" effect (Sabattier effect) where the
              image is wholly or partially reversed in
              tone.
              </notes>
            </value>
            <value optional="true">SEPIA
              <notes>
              A "sepia" effect where the image is mapped into warm
              gray, red, and brown tones.
              </notes>
            </value>
            <value optional="true">POSTERIZE
              <notes>
              A "posterization" effect where the image uses
              discrete regions of tone rather than a continuous
              gradient of tones.
              </notes>
            </value>
            <value optional="true">WHITEBOARD
              <notes>
              A "whiteboard" effect where the image is typically displayed
              as regions of white, with black or grey details.
              </notes>
            </value>
            <value optional="true">BLACKBOARD
              <notes>
              A "blackboard" effect where the image is typically displayed
              as regions of black, with white or grey details.
              </notes>
            </value>
            <value optional="true">AQUA
              <notes>
              An "aqua" effect where a blue hue is added to the image.
              </notes>
            </value>
          </enum>
          <description>A special color effect to apply.</description>
          <range>camera.control.availableEffects</range>
          <details>
          When this mode is set, a color effect will be applied
          to images produced by the camera device. The interpretation
          and implementation of these color effects is left to the
          implementor of the camera device, and should not be
          depended on to be consistent (or present) across all
          devices.
          </details>
          <tag id="BC" />
        </entry>
        <entry name="mode" type="byte" visibility="public" enum="true"
               hwlevel="legacy">
          <enum>
            <value>OFF
            <notes>Full application control of pipeline.

            All control by the device's metering and focusing (3A)
            routines is disabled, and no other settings in
            camera.control.* have any effect.

            However, the camera device's 3A routines may continue to
            collect statistics and update their internal state so that
            when control is switched to AUTO mode, good control values
            can be immediately applied.
            </notes></value>
            <value>AUTO
            <notes>Use settings for each individual 3A routine.

            Manual control of capture parameters is disabled. All
            controls in camera.control.* besides sceneMode take
            effect.</notes></value>
            <value>USE_SCENE_MODE
            <notes>Use a specific scene mode.

            Enabling this disables ae.mode, awb.mode and
            af.mode controls; the camera device will ignore
            those settings while USE_SCENE_MODE is active (except for
            FACE_PRIORITY scene mode). Other control entries are still
            active.  This setting can only be used if scene mode is
            supported (i.e. camera.control.availableSceneModes
            contain some modes other than DISABLED).</notes></value>
            <value>OFF_KEEP_STATE
            <notes>Same as OFF mode, except that this capture will not be
            used by camera device background auto-exposure, auto-white balance and
            auto-focus algorithms (3A) to update their statistics.

            Specifically, the 3A routines are locked to the last
            values set from a request with AUTO, OFF, or
            USE_SCENE_MODE, and any statistics or state updates
            collected from manual captures with OFF_KEEP_STATE will be
            discarded by the camera device.
            </notes></value>
          </enum>
          <description>Overall mode of 3A (auto-exposure, auto-white-balance, auto-focus) control
          routines.</description>
          <range>camera.control.availableModes</range>
          <details>
          This is a top-level 3A control switch. When set to OFF, all 3A control
          by the camera device is disabled. The application must set the fields for
          capture parameters itself.

          When set to AUTO, the individual algorithm controls in
          camera.*.mode are in effect, such as camera.af.mode.

          When set to USE_SCENE_MODE, the individual controls in
          camera.control.* are mostly disabled, and the camera device implements
          one of the scene mode settings (such as ACTION, SUNSET, or PARTY)
          as it wishes. The camera device scene mode 3A settings are provided by
          camera.control.sceneModeOverrides.

          When set to OFF_KEEP_STATE, it is similar to OFF mode, the only difference
          is that this frame will not be used by camera device background 3A statistics
          update, as if this frame is never captured. This mode can be used in the scenario
          where the application doesn't want a 3A manual control capture to affect
          the subsequent auto 3A capture results.

          LEGACY mode devices will only support AUTO and USE_SCENE_MODE modes.
          LIMITED mode devices will only support OFF and OFF_KEEP_STATE if they
          support the MANUAL_SENSOR and MANUAL_POST_PROCSESING capabilities.
          FULL mode devices will always support OFF and OFF_KEEP_STATE.
          </details>
          <tag id="BC" />
          <tag id="FUTURE" />
        </entry>
        <entry name="sceneMode" type="byte" visibility="public" enum="true"
               hwlevel="legacy">
          <enum>
            <value id="0">DISABLED
              <notes>
              Indicates that no scene modes are set for a given capture request.
              </notes>
            </value>
            <value>FACE_PRIORITY
              <notes>If face detection support exists, use face
              detection data for auto-focus, auto-white balance, and
              auto-exposure routines.

              If face detection statistics are disabled
              (i.e. camera.statistics.faceDetectMode is set to OFF),
              this should still operate correctly (but will not return
              face detection statistics to the framework).

              Unlike the other scene modes, camera.ae.mode,
              camera.awb.mode, and camera.af.mode
              remain active when FACE_PRIORITY is set.
              </notes>
            </value>
            <value optional="true">ACTION
              <notes>
              Optimized for photos of quickly moving objects.

              Similar to SPORTS.
              </notes>
            </value>
            <value optional="true">PORTRAIT
              <notes>
              Optimized for still photos of people.
              </notes>
            </value>
            <value optional="true">LANDSCAPE
              <notes>
              Optimized for photos of distant macroscopic objects.
              </notes>
            </value>
            <value optional="true">NIGHT
              <notes>
              Optimized for low-light settings.
              </notes>
            </value>
            <value optional="true">NIGHT_PORTRAIT
              <notes>
              Optimized for still photos of people in low-light
              settings.
              </notes>
            </value>
            <value optional="true">THEATRE
              <notes>
              Optimized for dim, indoor settings where flash must
              remain off.
              </notes>
            </value>
            <value optional="true">BEACH
              <notes>
              Optimized for bright, outdoor beach settings.
              </notes>
            </value>
            <value optional="true">SNOW
              <notes>
              Optimized for bright, outdoor settings containing snow.
              </notes>
            </value>
            <value optional="true">SUNSET
              <notes>
              Optimized for scenes of the setting sun.
              </notes>
            </value>
            <value optional="true">STEADYPHOTO
              <notes>
              Optimized to avoid blurry photos due to small amounts of
              device motion (for example: due to hand shake).
              </notes>
            </value>
            <value optional="true">FIREWORKS
              <notes>
              Optimized for nighttime photos of fireworks.
              </notes>
            </value>
            <value optional="true">SPORTS
              <notes>
              Optimized for photos of quickly moving people.

              Similar to ACTION.
              </notes>
            </value>
            <value optional="true">PARTY
              <notes>
              Optimized for dim, indoor settings with multiple moving
              people.
              </notes>
            </value>
            <value optional="true">CANDLELIGHT
              <notes>
              Optimized for dim settings where the main light source
              is a flame.
              </notes>
            </value>
            <value optional="true">BARCODE
              <notes>
              Optimized for accurately capturing a photo of barcode
              for use by camera applications that wish to read the
              barcode value.
              </notes>
            </value>
            <value optional="true">HIGH_SPEED_VIDEO
              <notes>
              Optimized for high speed video recording (frame rate >=60fps) use case.

              The supported high speed video sizes and fps ranges are specified in
              camera.control.availableHighSpeedVideoConfigurations. To get desired
              output frame rates, the application is only allowed to select video size
              and fps range combinations listed in this static metadata. The fps range
              can be control via camera.ae.targetFpsRange.

              In this mode, the camera device will override aeMode, awbMode, and afMode to
              ON, ON, and CONTINUOUS_VIDEO, respectively. All post-processing block mode
              controls will be overridden to be FAST. Therefore, no manual control of capture
              and post-processing parameters is possible. All other controls operate the
              same as when camera.control.mode == AUTO. This means that all other
              camera.control.* fields continue to work, such as

              * camera.ae.targetFpsRange
              * camera.ae.compensation
              * camera.ae.lock
              * camera.awb.lock
              * camera.control.effectMode
              * camera.ae.regions
              * camera.af.regions
              * camera.awb.regions
              * camera.af.trigger
              * camera.ae.precaptureTrigger

              Outside of camera.control.*, the following controls will work:

              * camera.flash.mode (automatic flash for still capture will not work since aeMode is ON)
              * camera.lens.opticalStabilizationMode (if it is supported)
              * camera.scaler.cropRegion
              * camera.statistics.faceDetectMode

              For high speed recording use case, the actual maximum supported frame rate may
              be lower than what camera can output, depending on the destination Surfaces for
              the image data. For example, if the destination surface is from video encoder,
              the application need check if the video encoder is capable of supporting the
              high frame rate for a given video size, or it will end up with lower recording
              frame rate. If the destination surface is from preview window, the preview frame
              rate will be bounded by the screen refresh rate.

              The camera device will only support up to 2 output high speed streams
              (processed non-stalling format defined in camera.request.maxNumOutputStreams)
              in this mode. This control will be effective only if all of below conditions are true:

              * The application created no more than maxNumHighSpeedStreams processed non-stalling
              format output streams, where maxNumHighSpeedStreams is calculated as
              min(2, camera.request.maxNumOutputStreams[Processed (but not-stalling)]).
              * The stream sizes are selected from the sizes reported by
              camera.control.availableHighSpeedVideoConfigurations.
              * No processed non-stalling or raw streams are configured.

              When above conditions are NOT satistied, the controls of this mode and
              camera.ae.targetFpsRange will be ignored by the camera device,
              the camera device will fall back to camera.control.mode `==` AUTO,
              and the returned capture result metadata will give the fps range choosen
              by the camera device.

              Switching into or out of this mode may trigger some camera ISP/sensor
              reconfigurations, which may introduce extra latency. It is recommended that
              the application avoids unnecessary scene mode switch as much as possible.
              </notes>
            </value>
            <value optional="true">HDR
              <notes>
              Turn on a device-specific high dynamic range (HDR) mode.

              In this scene mode, the camera device captures images
              that keep a larger range of scene illumination levels
              visible in the final image. For example, when taking a
              picture of a object in front of a bright window, both
              the object and the scene through the window may be
              visible when using HDR mode, while in normal AUTO mode,
              one or the other may be poorly exposed. As a tradeoff,
              HDR mode generally takes much longer to capture a single
              image, has no user control, and may have other artifacts
              depending on the HDR method used.

              Therefore, HDR captures operate at a much slower rate
              than regular captures.

              In this mode, on LIMITED or FULL devices, when a request
              is made for still capture, the camera device will capture an image
              using a high dynamic range capture technique.  On LEGACY
              devices, captures that target a JPEG-format output will
              be captured with HDR, and the capture intent is not
              relevant.

              The HDR capture may involve the device capturing a burst
              of images internally and combining them into one, or it
              may involve the device using specialized high dynamic
              range capture hardware. In all cases, a single image is
              produced in response to a capture request submitted
              while in HDR mode.

              Since substantial post-processing is generally needed to
              produce an HDR image, only YUV and JPEG outputs are
              supported for LIMITED/FULL device HDR captures, and only
              JPEG outputs are supported for LEGACY HDR
              captures. Using a RAW output for HDR capture is not
              supported.
              </notes>
            </value>
          </enum>
          <description>
          Control for which scene mode is currently active.
          </description>
          <range>camera.control.availableSceneModes</range>
          <details>
          Scene modes are custom camera modes optimized for a certain set of conditions and
          capture settings.

          This is the mode that that is active when
          `camera.control.mode == USE_SCENE_MODE`. Aside from FACE_PRIORITY,
          these modes will disable camera.ae.mode,
          camera.awb.mode, and camera.af.mode while in use.

          The interpretation and implementation of these scene modes is left
          to the implementor of the camera device. Their behavior will not be
          consistent across all devices, and any given device may only implement
          a subset of these modes.
          </details>
          <hal_details>
          HAL implementations that include scene modes are expected to provide
          the per-scene settings to use for camera.ae.mode,
          camera.awb.mode, and camera.af.mode in
          camera.control.sceneModeOverrides.

          For HIGH_SPEED_VIDEO mode, if it is included in camera.control.availableSceneModes,
          the HAL must list supported video size and fps range in
          camera.control.availableHighSpeedVideoConfigurations. For a given size, e.g.
          1280x720, if the HAL has two different sensor configurations for normal streaming
          mode and high speed streaming, when this scene mode is set/reset in a sequence of capture
          requests, the HAL may have to switch between different sensor modes.
          </hal_details>
          <tag id="BC" />
          <tag id="FUTURE" />
        </entry>
        <entry name="videoStabilizationMode" type="byte" visibility="public"
               enum="true" hwlevel="legacy">
          <enum>
            <value>OFF
            <notes>
              Video stabilization is disabled.
            </notes></value>
            <value>ON
            <notes>
              Video stabilization is enabled.
            </notes></value>
          </enum>
          <description>Whether video stabilization is
          active.</description>
          <details>
          Video stabilization automatically translates and scales images from
          the camera in order to stabilize motion between consecutive frames.

          If enabled, video stabilization can modify the
          camera.scaler.cropRegion to keep the video stream stabilized.

          Switching between different video stabilization modes may take several
          frames to initialize, the camera device will report the current mode
          in capture result metadata. For example, When "ON" mode is requested,
          the video stabilization modes in the first several capture results may
          still be "OFF", and it will become "ON" when the initialization is
          done.

          If a camera device supports both this mode and OIS
          (camera.lens.opticalStabilizationMode), turning both modes on may
          produce undesirable interaction, so it is recommended not to enable
          both at the same time.
          </details>
          <tag id="BC" />
        </entry>
      </controls>
      <static>
        <entry name="availableEffects" type="byte" visibility="public"
               type_notes="List of enums (camera.control.effectMode)." container="array"
               typedef="enumList" hwlevel="legacy">
          <array>
            <size>n</size>
          </array>
          <description>
          List of color effects for camera.control.effectMode that are supported by this camera
          device.
          </description>
          <range>Any value listed in camera.control.effectMode</range>
          <details>
          This list contains the color effect modes that can be applied to
          images produced by the camera device.
          Implementations are not expected to be consistent across all devices.
          If no color effect modes are available for a device, this will only list
          OFF.

          A color effect will only be applied if
          camera.control.mode != OFF.  OFF is always included in this list.

          This control has no effect on the operation of other control routines such
          as auto-exposure, white balance, or focus.
          </details>
          <tag id="BC" />
        </entry>
        <entry name="availableModes" type="byte" visibility="public"
               type_notes="List of enums (camera.control.mode)." container="array"
               typedef="enumList" hwlevel="legacy">
          <array>
            <size>n</size>
          </array>
          <description>
          List of control modes for camera.control.mode that are supported by this camera
          device.
          </description>
          <range>Any value listed in camera.control.mode</range>
          <details>
          This list contains control modes that can be set for the camera device.
          LEGACY mode devices will always support AUTO mode.
          LIMITED and FULL devices will always support OFF, AUTO modes.
          </details>
          <tag id="BC" />
        </entry>
        <entry name="availableSceneModes" type="byte" visibility="public"
               type_notes="List of enums (camera.control.sceneMode)."
               container="array" typedef="enumList" hwlevel="legacy">
          <array>
            <size>n</size>
          </array>
          <description>
          List of scene modes for camera.control.sceneMode that are supported by this camera
          device.
          </description>
          <range>Any value listed in camera.control.sceneMode</range>
          <details>
          This list contains scene modes that can be set for the camera device.
          Only scene modes that have been fully implemented for the
          camera device may be included here. Implementations are not expected
          to be consistent across all devices.

          If no scene modes are supported by the camera device, this
          will be set to DISABLED. Otherwise DISABLED will not be listed.

          FACE_PRIORITY is always listed if face detection is
          supported (i.e.`camera.statistics.info.maxFaceCount &gt;
          0`).
          </details>
          <tag id="BC" />
          <tag id="FUTURE" />
        </entry>
        <entry name="availableVideoStabilizationModes" type="byte"
               visibility="public" type_notes="List of enums." container="array"
               typedef="enumList" hwlevel="legacy">
          <array>
            <size>n</size>
          </array>
          <description>
          List of video stabilization modes for camera.control.videoStabilizationMode
          that are supported by this camera device.
          </description>
          <range>Any value listed in camera.control.videoStabilizationMode</range>
          <details>
          OFF will always be listed.
          </details>
          <tag id="BC" />
        </entry>
        <entry name="maxRegions" type="int32" visibility="hidden"
               container="array" hwlevel="legacy">
          <array>
            <size>3</size>
          </array>
          <description>
          List of the maximum number of regions that can be used for metering in
          auto-exposure (AE), auto-white balance (AWB), and auto-focus (AF);
          this corresponds to the the maximum number of elements in
          camera.ae.regions, camera.awb.regions,
          and camera.af.regions.
          </description>
          <range>
          Value must be &amp;gt;= 0 for each element. For full-capability devices
          this value must be &amp;gt;= 1 for AE and AF. The order of the elements is:
          `(AE, AWB, AF)`.</range>
          <tag id="BC" />
        </entry>
        <entry name="sceneModeOverrides" type="byte" visibility="system"
               container="array" hwlevel="limited">
          <array>
            <size>3</size>
            <size>length(availableSceneModes)</size>
          </array>
          <description>
          Ordered list of auto-exposure, auto-white balance, and auto-focus
          settings to use with each available scene mode.
          </description>
          <range>
          For each available scene mode, the list must contain three
          entries containing the camera.ae.mode,
          camera.awb.mode, and camera.af.mode values used
          by the camera device. The entry order is `(aeMode, awbMode, afMode)`
          where aeMode has the lowest index position.
          </range>
          <details>
          When a scene mode is enabled, the camera device is expected
          to override camera.ae.mode, camera.awb.mode,
          and camera.af.mode with its preferred settings for
          that scene mode.

          The order of this list matches that of availableSceneModes,
          with 3 entries for each mode.  The overrides listed
          for FACE_PRIORITY are ignored, since for that
          mode the application-set camera.ae.mode,
          camera.awb.mode, and camera.af.mode values are
          used instead, matching the behavior when camera.control.mode
          is set to AUTO. It is recommended that the FACE_PRIORITY
          overrides should be set to 0.

          For example, if availableSceneModes contains
          `(FACE_PRIORITY, ACTION, NIGHT)`,  then the camera framework
          expects sceneModeOverrides to have 9 entries formatted like:
          `(0, 0, 0, ON_AUTO_FLASH, AUTO, CONTINUOUS_PICTURE,
          ON_AUTO_FLASH, INCANDESCENT, AUTO)`.
          </details>
          <hal_details>
          To maintain backward compatibility, this list will be made available
          in the static metadata of the camera service.  The camera service will
          use these values to set camera.ae.mode,
          camera.awb.mode, and camera.af.mode when using a scene
          mode other than FACE_PRIORITY.
          </hal_details>
          <tag id="BC" />
          <tag id="FUTURE" />
        </entry>
      </static>
      <dynamic>
        <clone entry="camera.control.effectMode" kind="controls">
        </clone>
        <clone entry="camera.control.mode" kind="controls">
        </clone>
        <clone entry="camera.control.sceneMode" kind="controls">
        </clone>
        <clone entry="camera.control.videoStabilizationMode" kind="controls">
        </clone>
      </dynamic>
      <static>
        <entry name="availableHighSpeedVideoConfigurations" type="int32" visibility="hidden"
               container="array" typedef="highSpeedVideoConfiguration" hwlevel="limited">
          <array>
            <size>4</size>
            <size>n</size>
          </array>
          <description>
          List of available high speed video size and fps range configurations
          supported by the camera device, in the format of (width, height, fps_min, fps_max).
          </description>
          <range>
          For each configuration, the fps_max &amp;gt;= 60fps.
          </range>
          <details>
          When HIGH_SPEED_VIDEO is supported in camera.control.availableSceneModes,
          this metadata will list the supported high speed video size and fps range
          configurations. All the sizes listed in this configuration will be a subset
          of the sizes reported by StreamConfigurationMap#getOutputSizes for processed
          non-stalling formats.

          For the high speed video use case, where the application will set
          camera.control.sceneMode to HIGH_SPEED_VIDEO in capture requests, the application must
          select the video size and fps range from this metadata to configure the recording and
          preview streams and setup the recording requests. For example, if the application intends
          to do high speed recording, it can select the maximum size reported by this metadata to
          configure output streams. Once the size is selected, application can filter this metadata
          by selected size and get the supported fps ranges, and use these fps ranges to setup the
          recording requests. Note that for the use case of multiple output streams, application
          must select one unique size from this metadata to use. Otherwise a request error might
          occur.

          For normal video recording use case, where some application will NOT set
          camera.control.sceneMode to HIGH_SPEED_VIDEO in capture requests, the fps ranges
          reported in this metadata must not be used to setup capture requests, or it will cause
          request error.
          </details>
          <hal_details>
          All the sizes listed in this configuration will be a subset of the sizes reported by
          camera.scaler.availableStreamConfigurations for processed non-stalling output formats.
          Note that for all high speed video configurations, HAL must be able to support a minimum
          of two streams, though the application might choose to configure just one stream.

          Since the HIGH_SPEED_VIDEO mode may be turned on for preview view only case, the preview
          fps is bounded by device refresh rate (e.g. 60fps). For a given resolution, it is
          recommended that this list includes some fps ranges (e.g. [30, 60]) that is suitable
          for preview only streaming case.
          </hal_details>
          <tag id="V1" />
          <tag id="FUTURE" />
        </entry>
      </static>
    </section>
    <section name="demosaic">
      <controls>
        <entry name="mode" type="byte" enum="true">
          <enum>
            <value>FAST
            <notes>Minimal or no slowdown of frame rate compared to
            Bayer RAW output.</notes></value>
            <value>HIGH_QUALITY
            <notes>Improved processing quality but the frame rate is slowed down
            relative to raw output.</notes></value>
          </enum>
          <description>Controls the quality of the demosaicing
          processing.</description>
          <tag id="FUTURE" />
        </entry>
      </controls>
    </section>
    <section name="edge">
      <controls>
        <entry name="mode" type="byte" visibility="public" enum="true" hwlevel="full">
          <enum>
            <value>OFF
            <notes>No edge enhancement is applied.</notes></value>
            <value>FAST
            <notes>Apply edge enhancement at a quality level that does not slow down frame rate relative to sensor
            output</notes></value>
            <value>HIGH_QUALITY
            <notes>Apply high-quality edge enhancement, at a cost of reducing output frame rate.
            </notes></value>
          </enum>
          <description>Operation mode for edge
          enhancement.</description>
          <range>camera.edge.availableEdgeModes</range>
          <details>Edge enhancement improves sharpness and details in the captured image. OFF means
          no enhancement will be applied by the camera device.

          FAST/HIGH_QUALITY both mean camera device determined enhancement
          will be applied. HIGH_QUALITY mode indicates that the
          camera device will use the highest-quality enhancement algorithms,
          even if it slows down capture rate. FAST means the camera device will
          not slow down capture rate when applying edge enhancement.</details>
          <tag id="V1" />
        </entry>
        <entry name="strength" type="byte">
          <description>Control the amount of edge enhancement
          applied to the images</description>
          <units>1-10; 10 is maximum sharpening</units>
          <tag id="FUTURE" />
        </entry>
      </controls>
      <static>
        <entry name="availableEdgeModes" type="byte" visibility="public"
               type_notes="list of enums" container="array" typedef="enumList"
               hwlevel="full">
          <array>
            <size>n</size>
          </array>
          <description>
          List of edge enhancement modes for camera.edge.mode that are supported by this camera
          device.
          </description>
          <range>Any value listed in camera.edge.mode</range>
          <details>
          Full-capability camera devices must always support OFF; all devices will list FAST.
          </details>
          <tag id="V1" />
        </entry>
      </static>
      <dynamic>
        <clone entry="camera.edge.mode" kind="controls">
          <tag id="V1" />
        </clone>
      </dynamic>
    </section>
    <section name="flash">
      <controls>
        <entry name="firingPower" type="byte">
          <description>Power for flash firing/torch</description>
          <units>10 is max power; 0 is no flash. Linear</units>
          <range>0 - 10</range>
          <details>Power for snapshot may use a different scale than
          for torch mode. Only one entry for torch mode will be
          used</details>
          <tag id="FUTURE" />
        </entry>
        <entry name="firingTime" type="int64">
          <description>Firing time of flash relative to start of
          exposure</description>
          <units>nanoseconds</units>
          <range>0-(exposure time-flash duration)</range>
          <details>Clamped to (0, exposure time - flash
          duration).</details>
          <tag id="FUTURE" />
        </entry>
        <entry name="mode" type="byte" visibility="public" enum="true" hwlevel="legacy">
          <enum>
            <value>OFF
              <notes>
              Do not fire the flash for this capture.
              </notes>
            </value>
            <value>SINGLE
              <notes>
              If the flash is available and charged, fire flash
              for this capture.
              </notes>
            </value>
            <value>TORCH
              <notes>
              Transition flash to continuously on.
              </notes>
            </value>
          </enum>
          <description>The desired mode for for the camera device's flash control.</description>
          <details>
          This control is only effective when flash unit is available
          (`camera.flash.info.available == true`).

          When this control is used, the camera.ae.mode must be set to ON or OFF.
          Otherwise, the camera device auto-exposure related flash control (ON_AUTO_FLASH,
          ON_ALWAYS_FLASH, or ON_AUTO_FLASH_REDEYE) will override this control.

          When set to OFF, the camera device will not fire flash for this capture.

          When set to SINGLE, the camera device will fire flash regardless of the camera
          device's auto-exposure routine's result. When used in still capture case, this
          control should be used along with auto-exposure (AE) precapture metering sequence
          (camera.ae.precaptureTrigger), otherwise, the image may be incorrectly exposed.

          When set to TORCH, the flash will be on continuously. This mode can be used
          for use cases such as preview, auto-focus assist, still capture, or video recording.

          The flash status will be reported by camera.flash.state in the capture result metadata.
          </details>
          <tag id="BC" />
        </entry>
      </controls>
      <static>
        <namespace name="info">
          <entry name="available" type="byte" visibility="public" enum="true"
                 typedef="boolean" hwlevel="legacy">
            <enum>
              <value>FALSE</value>
              <value>TRUE</value>
            </enum>
            <description>Whether this camera device has a
            flash unit.</description>
            <details>
            Will be `false` if no flash is available.

            If there is no flash unit, none of the flash controls do
            anything.</details>
            <tag id="BC" />
          </entry>
          <entry name="chargeDuration" type="int64">
            <description>Time taken before flash can fire
            again</description>
            <units>nanoseconds</units>
            <range>0-1e9</range>
            <details>1 second too long/too short for recharge? Should
            this be power-dependent?</details>
            <tag id="FUTURE" />
          </entry>
        </namespace>
        <entry name="colorTemperature" type="byte">
          <description>The x,y whitepoint of the
          flash</description>
          <units>pair of floats</units>
          <range>0-1 for both</range>
          <tag id="FUTURE" />
        </entry>
        <entry name="maxEnergy" type="byte">
          <description>Max energy output of the flash for a full
          power single flash</description>
          <units>lumen-seconds</units>
          <range>&amp;gt;= 0</range>
          <tag id="FUTURE" />
        </entry>
      </static>
      <dynamic>
        <clone entry="camera.flash.firingPower" kind="controls">
        </clone>
        <clone entry="camera.flash.firingTime" kind="controls">
        </clone>
        <clone entry="camera.flash.mode" kind="controls"></clone>
        <entry name="state" type="byte" visibility="public" enum="true"
               hwlevel="limited">
          <enum>
            <value>UNAVAILABLE
            <notes>No flash on camera.</notes></value>
            <value>CHARGING
            <notes>Flash is charging and cannot be fired.</notes></value>
            <value>READY
            <notes>Flash is ready to fire.</notes></value>
            <value>FIRED
            <notes>Flash fired for this capture.</notes></value>
            <value>PARTIAL
            <notes>Flash partially illuminated this frame.

            This is usually due to the next or previous frame having
            the flash fire, and the flash spilling into this capture
            due to hardware limitations.</notes></value>
          </enum>
          <description>Current state of the flash
          unit.</description>
          <details>
          When the camera device doesn't have flash unit
          (i.e. `camera.flash.info.available == false`), this state will always be UNAVAILABLE.
          Other states indicate the current flash status.

          In certain conditions, this will be available on LEGACY devices:

           * Flash-less cameras always return UNAVAILABLE.
           * Using camera.ae.mode `==` ON_ALWAYS_FLASH
             will always return FIRED.
           * Using camera.flash.mode `==` TORCH
             will always return FIRED.

          In all other conditions the state will not be available on
          LEGACY devices (i.e. it will be `null`).
          </details>
        </entry>
      </dynamic>
    </section>
    <section name="hotPixel">
      <controls>
        <entry name="mode" type="byte" visibility="public" enum="true">
          <enum>
            <value>OFF
              <notes>
              No hot pixel correction is applied.

              The frame rate must not be reduced relative to sensor raw output
              for this option.

              The hotpixel map may be returned in camera.statistics.hotPixelMap.
              </notes>
            </value>
            <value>FAST
              <notes>
              Hot pixel correction is applied, without reducing frame
              rate relative to sensor raw output.

              The hotpixel map may be returned in camera.statistics.hotPixelMap.
              </notes>
            </value>
            <value>HIGH_QUALITY
              <notes>
              High-quality hot pixel correction is applied, at a cost
              of reducing frame rate relative to sensor raw output.

              The hotpixel map may be returned in camera.statistics.hotPixelMap.
              </notes>
            </value>
          </enum>
          <description>
          Operational mode for hot pixel correction.
          </description>
          <range>camera.hotPixel.availableHotPixelModes</range>
          <details>
          Hotpixel correction interpolates out, or otherwise removes, pixels
          that do not accurately measure the incoming light (i.e. pixels that
          are stuck at an arbitrary value or are oversensitive).
          </details>
          <tag id="V1" />
          <tag id="RAW" />
        </entry>
      </controls>
      <static>
        <entry name="availableHotPixelModes" type="byte" visibility="public"
          type_notes="list of enums" container="array" typedef="enumList">
          <array>
            <size>n</size>
          </array>
          <description>
          List of hot pixel correction modes for camera.hotPixel.mode that are supported by this
          camera device.
          </description>
          <range>Any value listed in camera.hotPixel.mode</range>
          <details>
          FULL mode camera devices will always support FAST.
          </details>
          <hal_details>
          To avoid performance issues, there will be significantly fewer hot
          pixels than actual pixels on the camera sensor.
          </hal_details>
          <tag id="V1" />
          <tag id="RAW" />
        </entry>
      </static>
      <dynamic>
        <clone entry="camera.hotPixel.mode" kind="controls">
          <tag id="V1" />
          <tag id="RAW" />
        </clone>
      </dynamic>
    </section>
    <section name="jpeg">
      <controls>
        <entry name="gpsLocation" type="byte" visibility="public" synthetic="true"
        typedef="location" hwlevel="legacy">
          <description>
          A location object to use when generating image GPS metadata.
          </description>
          <details>
          Setting a location object in a request will include the GPS coordinates of the location
          into any JPEG images captured based on the request. These coordinates can then be
          viewed by anyone who receives the JPEG image.
          </details>
        </entry>
        <entry name="gpsCoordinates" type="double" visibility="hidden"
        type_notes="latitude, longitude, altitude. First two in degrees, the third in meters"
        container="array" hwlevel="legacy">
          <array>
            <size>3</size>
          </array>
          <description>GPS coordinates to include in output JPEG
          EXIF.</description>
          <range>(-180 - 180], [-90,90], [-inf, inf]</range>
          <tag id="BC" />
        </entry>
        <entry name="gpsProcessingMethod" type="byte" visibility="hidden"
               typedef="string" hwlevel="legacy">
          <description>32 characters describing GPS algorithm to
          include in EXIF.</description>
          <units>UTF-8 null-terminated string</units>
          <tag id="BC" />
        </entry>
        <entry name="gpsTimestamp" type="int64" visibility="hidden" hwlevel="legacy">
          <description>Time GPS fix was made to include in
          EXIF.</description>
          <units>UTC in seconds since January 1, 1970</units>
          <tag id="BC" />
        </entry>
        <entry name="orientation" type="int32" visibility="public" hwlevel="legacy">
          <description>The orientation for a JPEG image.</description>
          <units>Degrees in multiples of 90</units>
          <range>0, 90, 180, 270</range>
          <details>
          The clockwise rotation angle in degrees, relative to the orientation
          to the camera, that the JPEG picture needs to be rotated by, to be viewed
          upright.

          Camera devices may either encode this value into the JPEG EXIF header, or
          rotate the image data to match this orientation.

          Note that this orientation is relative to the orientation of the camera sensor, given
          by camera.sensor.orientation.

          To translate from the device orientation given by the camera sensor APIs, the following
          sample code may be used:

              private int getJpegOrientation(CameraCharacteristics c, int deviceOrientation) {
                  if (deviceOrientation == camera.view.OrientationEventListener.ORIENTATION_UNKNOWN) return 0;
                  int sensorOrientation = c.get(CameraCharacteristics.SENSOR_ORIENTATION);

                  // Round device orientation to a multiple of 90
                  deviceOrientation = (deviceOrientation + 45) / 90 * 90;

                  // Reverse device orientation for front-facing cameras
                  boolean facingFront = c.get(CameraCharacteristics.LENS_FACING) == CameraCharacteristics.LENS_FACING_FRONT;
                  if (facingFront) deviceOrientation = -deviceOrientation;

                  // Calculate desired JPEG orientation relative to camera orientation to make
                  // the image upright relative to the device orientation
                  int jpegOrientation = (sensorOrientation + deviceOrientation + 360) % 360;

                  return jpegOrientation;
              }
          </details>
          <tag id="BC" />
        </entry>
        <entry name="quality" type="byte" visibility="public" hwlevel="legacy">
          <description>Compression quality of the final JPEG
          image.</description>
          <range>1-100; larger is higher quality</range>
          <details>85-95 is typical usage range.</details>
          <tag id="BC" />
        </entry>
        <entry name="thumbnailQuality" type="byte" visibility="public" hwlevel="legacy">
          <description>Compression quality of JPEG
          thumbnail.</description>
          <range>1-100; larger is higher quality</range>
          <tag id="BC" />
        </entry>
        <entry name="thumbnailSize" type="int32" visibility="public"
        container="array" typedef="size" hwlevel="legacy">
          <array>
            <size>2</size>
          </array>
          <description>Resolution of embedded JPEG thumbnail.</description>
          <range>camera.jpeg.availableThumbnailSizes</range>
          <details>When set to (0, 0) value, the JPEG EXIF will not contain thumbnail,
          but the captured JPEG will still be a valid image.

          For best results, when issuing a request for a JPEG image, the thumbnail size selected
          should have the same aspect ratio as the main JPEG output.

          If the thumbnail image aspect ratio differs from the JPEG primary image aspect
          ratio, the camera device creates the thumbnail by cropping it from the primary image.
          For example, if the primary image has 4:3 aspect ratio, the thumbnail image has
          16:9 aspect ratio, the primary image will be cropped vertically (letterbox) to
          generate the thumbnail image. The thumbnail image will always have a smaller Field
          Of View (FOV) than the primary image when aspect ratios differ.
          </details>
          <hal_details>
          The HAL must not squeeze or stretch the downscaled primary image to generate thumbnail.
          The cropping must be done on the primary jpeg image rather than the sensor active array.
          The stream cropping rule specified by "S5. Cropping" in camera3.h doesn't apply to the
          thumbnail image cropping.
          </hal_details>
          <tag id="BC" />
        </entry>
      </controls>
      <static>
        <entry name="availableThumbnailSizes" type="int32" visibility="public"
        container="array" typedef="size" hwlevel="legacy">
          <array>
            <size>2</size>
            <size>n</size>
          </array>
          <description>List of JPEG thumbnail sizes for camera.jpeg.thumbnailSize supported by this
          camera device.</description>
          <details>
          This list will include at least one non-zero resolution, plus `(0,0)` for indicating no
          thumbnail should be generated.

          Below condiditions will be satisfied for this size list:

          * The sizes will be sorted by increasing pixel area (width x height).
          If several resolutions have the same area, they will be sorted by increasing width.
          * The aspect ratio of the largest thumbnail size will be same as the
          aspect ratio of largest JPEG output size in camera.scaler.availableStreamConfigurations.
          The largest size is defined as the size that has the largest pixel area
          in a given size list.
          * Each output JPEG size in camera.scaler.availableStreamConfigurations will have at least
          one corresponding size that has the same aspect ratio in availableThumbnailSizes,
          and vice versa.
          * All non-`(0, 0)` sizes will have non-zero widths and heights.</details>
          <tag id="BC" />
        </entry>
        <entry name="maxSize" type="int32" visibility="system">
          <description>Maximum size in bytes for the compressed
          JPEG buffer</description>
          <range>Must be large enough to fit any JPEG produced by
          the camera</range>
          <details>This is used for sizing the gralloc buffers for
          JPEG</details>
        </entry>
      </static>
      <dynamic>
        <clone entry="camera.jpeg.gpsLocation" kind="controls">
        </clone>
        <clone entry="camera.jpeg.gpsCoordinates" kind="controls">
        </clone>
        <clone entry="camera.jpeg.gpsProcessingMethod"
        kind="controls"></clone>
        <clone entry="camera.jpeg.gpsTimestamp" kind="controls">
        </clone>
        <clone entry="camera.jpeg.orientation" kind="controls">
        </clone>
        <clone entry="camera.jpeg.quality" kind="controls">
        </clone>
        <entry name="size" type="int32">
          <description>The size of the compressed JPEG image, in
          bytes</description>
          <range>&amp;gt;= 0</range>
          <details>If no JPEG output is produced for the request,
          this must be 0.

          Otherwise, this describes the real size of the compressed
          JPEG image placed in the output stream.  More specifically,
          if camera.jpeg.maxSize = 1000000, and a specific capture
          has camera.jpeg.size = 500000, then the output buffer from
          the JPEG stream will be 1000000 bytes, of which the first
          500000 make up the real data.</details>
          <tag id="HALV3" />
        </entry>
        <clone entry="camera.jpeg.thumbnailQuality"
        kind="controls"></clone>
        <clone entry="camera.jpeg.thumbnailSize" kind="controls">
        </clone>
      </dynamic>
    </section>
    <section name="lens">
      <controls>
        <entry name="aperture" type="float" visibility="public" hwlevel="full">
          <description>The desired lens aperture size, as a ratio of lens focal length to the
          effective aperture diameter.</description>
          <units>The f-number (f/N)</units>
          <range>camera.lens.info.availableApertures</range>
          <details>Setting this value is only supported on the camera devices that have a variable
          aperture lens.

          When this is supported and camera.ae.mode is OFF,
          this can be set along with camera.sensor.exposureTime,
          camera.sensor.sensitivity, and camera.sensor.frameDuration
          to achieve manual exposure control.

          The requested aperture value may take several frames to reach the
          requested value; the camera device will report the current (intermediate)
          aperture size in capture result metadata while the aperture is changing.
          While the aperture is still changing, camera.lens.state will be set to MOVING.

          When this is supported and camera.ae.mode is one of
          the ON modes, this will be overridden by the camera device
          auto-exposure algorithm, the overridden values are then provided
          back to the user in the corresponding result.</details>
          <tag id="V1" />
        </entry>
        <entry name="filterDensity" type="float" visibility="public" hwlevel="full">
          <description>
          The desired setting for the lens neutral density filter(s).
          </description>
          <units>Exposure Value (EV)</units>
          <range>camera.lens.info.availableFilterDensities</range>
          <details>
          This control will not be supported on most camera devices.

          Lens filters are typically used to lower the amount of light the
          sensor is exposed to (measured in steps of EV). As used here, an EV
          step is the standard logarithmic representation, which are
          non-negative, and inversely proportional to the amount of light
          hitting the sensor.  For example, setting this to 0 would result
          in no reduction of the incoming light, and setting this to 2 would
          mean that the filter is set to reduce incoming light by two stops
          (allowing 1/4 of the prior amount of light to the sensor).

          It may take several frames before the lens filter density changes
          to the requested value. While the filter density is still changing,
          camera.lens.state will be set to MOVING.
          </details>
          <tag id="V1" />
        </entry>
        <entry name="focalLength" type="float" visibility="public" hwlevel="legacy">
          <description>
          The desired lens focal length; used for optical zoom.
          </description>
          <units>Millimeters</units>
          <range>camera.lens.info.availableFocalLengths</range>
          <details>
          This setting controls the physical focal length of the camera
          device's lens. Changing the focal length changes the field of
          view of the camera device, and is usually used for optical zoom.

          Like camera.lens.focusDistance and camera.lens.aperture, this
          setting won't be applied instantaneously, and it may take several
          frames before the lens can change to the requested focal length.
          While the focal length is still changing, camera.lens.state will
          be set to MOVING.

          Optical zoom will not be supported on most devices.
          </details>
          <tag id="V1" />
        </entry>
        <entry name="focusDistance" type="float" visibility="public" hwlevel="full">
          <description>Desired distance to plane of sharpest focus,
          measured from frontmost surface of the lens.</description>
          <units>See camera.lens.info.focusDistanceCalibration for details</units>
          <range>&amp;gt;= 0</range>
          <details>
          This control can be used for setting manual focus, on devices that support
          the MANUAL_SENSOR capability and have a variable-focus lens (see
          camera.lens.info.minimumFocusDistance).

          A value of `0.0f` means infinity focus. The value set will be clamped to
          `[0.0f, camera.lens.info.minimumFocusDistance]`.

          Like camera.lens.focalLength, this setting won't be applied
          instantaneously, and it may take several frames before the lens
          can move to the requested focus distance. While the lens is still moving,
          camera.lens.state will be set to MOVING.

          LEGACY devices support at most setting this to `0.0f`
          for infinity focus.
          </details>
          <tag id="BC" />
          <tag id="V1" />
        </entry>
        <entry name="opticalStabilizationMode" type="byte" visibility="public"
        enum="true" hwlevel="limited">
          <enum>
            <value>OFF
              <notes>Optical stabilization is unavailable.</notes>
            </value>
            <value optional="true">ON
              <notes>Optical stabilization is enabled.</notes>
            </value>
          </enum>
          <description>
          Sets whether the camera device uses optical image stabilization (OIS)
          when capturing images.
          </description>
          <range>camera.lens.info.availableOpticalStabilization</range>
          <details>
          OIS is used to compensate for motion blur due to small
          movements of the camera during capture. Unlike digital image
          stabilization (camera.control.videoStabilizationMode), OIS
          makes use of mechanical elements to stabilize the camera
          sensor, and thus allows for longer exposure times before
          camera shake becomes apparent.

          Switching between different optical stabilization modes may take several
          frames to initialize, the camera device will report the current mode in
          capture result metadata. For example, When "ON" mode is requested, the
          optical stabilization modes in the first several capture results may still
          be "OFF", and it will become "ON" when the initialization is done.

          If a camera device supports both OIS and digital image stabilization
          (camera.control.videoStabilizationMode), turning both modes on may produce undesirable
          interaction, so it is recommended not to enable both at the same time.

          Not all devices will support OIS; see
          camera.lens.info.availableOpticalStabilization for
          available controls.
          </details>
          <tag id="V1" />
        </entry>
      </controls>
      <static>
        <namespace name="info">
          <entry name="availableApertures" type="float" visibility="public"
          container="array" hwlevel="full">
            <array>
              <size>n</size>
            </array>
            <description>List of aperture size values for camera.lens.aperture that are
            supported by this camera device.</description>
            <units>The aperture f-number</units>
            <details>If the camera device doesn't support a variable lens aperture,
            this list will contain only one value, which is the fixed aperture size.

            If the camera device supports a variable aperture, the aperture values
            in this list will be sorted in ascending order.</details>
            <tag id="V1" />
          </entry>
          <entry name="availableFilterDensities" type="float" visibility="public"
          container="array" hwlevel="full">
            <array>
              <size>n</size>
            </array>
            <description>
            List of neutral density filter values for
            camera.lens.filterDensity that are supported by this camera device.
            </description>
            <units>Exposure value (EV)</units>
            <range>
            Values are &amp;gt;= 0
            </range>
            <details>
            If a neutral density filter is not supported by this camera device,
            this list will contain only 0. Otherwise, this list will include every
            filter density supported by the camera device, in ascending order.
            </details>
            <tag id="V1" />
          </entry>
          <entry name="availableFocalLengths" type="float" visibility="public"
          type_notes="The list of available focal lengths"
          container="array" hwlevel="legacy">
            <array>
              <size>n</size>
            </array>
            <description>
            List of focal lengths for camera.lens.focalLength that are supported by this camera
            device.
            </description>
            <units>Millimeters</units>
            <range>
            Values are &amp;gt; 0
            </range>
            <details>
            If optical zoom is not supported, this list will only contain
            a single value corresponding to the fixed focal length of the
            device. Otherwise, this list will include every focal length supported
            by the camera device, in ascending order.
            </details>
            <tag id="BC" />
            <tag id="V1" />
          </entry>
          <entry name="availableOpticalStabilization" type="byte"
          visibility="public" type_notes="list of enums" container="array"
          typedef="enumList" hwlevel="limited">
            <array>
              <size>n</size>
            </array>
            <description>
            List of optical image stabilization (OIS) modes for
            camera.lens.opticalStabilizationMode that are supported by this camera device.
            </description>
            <range>Any value listed in camera.lens.opticalStabilizationMode</range>
            <details>
            If OIS is not supported by a given camera device, this list will
            contain only OFF.
            </details>
            <tag id="V1" />
          </entry>
          <entry name="hyperfocalDistance" type="float" visibility="public" optional="true"
                 hwlevel="limited">
            <description>Hyperfocal distance for this lens.</description>
            <units>See camera.lens.info.focusDistanceCalibration for details</units>
            <range>If lens is fixed focus, &amp;gt;= 0. If lens has focuser unit, the value is
            within `(0.0f, camera.lens.info.minimumFocusDistance]`</range>
            <details>
            If the lens is not fixed focus, the camera device will report this
            field when camera.lens.info.focusDistanceCalibration is APPROXIMATE or CALIBRATED.
            </details>
          </entry>
          <entry name="minimumFocusDistance" type="float" visibility="public" optional="true"
                 hwlevel="limited">
            <description>Shortest distance from frontmost surface
            of the lens that can be brought into sharp focus.</description>
            <units>See camera.lens.info.focusDistanceCalibration for details</units>
            <range>&amp;gt;= 0</range>
            <details>If the lens is fixed-focus, this will be
            0.</details>
            <hal_details>Mandatory for FULL devices; LIMITED devices
            must always set this value to 0 for fixed-focus; and may omit
            the minimum focus distance otherwise.

            This field is also mandatory for all devices advertising
            the MANUAL_SENSOR capability.</hal_details>
            <tag id="V1" />
          </entry>
          <entry name="shadingMapSize" type="int32" visibility="hidden"
                 type_notes="width and height (N, M) of lens shading map provided by the camera device."
                 container="array" typedef="size" hwlevel="full">
            <array>
              <size>2</size>
            </array>
            <description>Dimensions of lens shading map.</description>
            <range>Both values &amp;gt;= 1</range>
            <details>
            The map should be on the order of 30-40 rows and columns, and
            must be smaller than 64x64.
            </details>
            <tag id="V1" />
          </entry>
          <entry name="focusDistanceCalibration" type="byte" visibility="public"
                 enum="true" hwlevel="limited">
            <enum>
              <value>UNCALIBRATED
                <notes>
                The lens focus distance is not accurate, and the units used for
                camera.lens.focusDistance do not correspond to any physical units.

                Setting the lens to the same focus distance on separate occasions may
                result in a different real focus distance, depending on factors such
                as the orientation of the device, the age of the focusing mechanism,
                and the device temperature. The focus distance value will still be
                in the range of `[0, camera.lens.info.minimumFocusDistance]`, where 0
                represents the farthest focus.
                </notes>
              </value>
              <value>APPROXIMATE
                <notes>
                The lens focus distance is measured in diopters.

                However, setting the lens to the same focus distance
                on separate occasions may result in a different real
                focus distance, depending on factors such as the
                orientation of the device, the age of the focusing
                mechanism, and the device temperature.
                </notes>
              </value>
              <value>CALIBRATED
                <notes>
                The lens focus distance is measured in diopters, and
                is calibrated.

                The lens mechanism is calibrated so that setting the
                same focus distance is repeatable on multiple
                occasions with good accuracy, and the focus distance
                corresponds to the real physical distance to the plane
                of best focus.
                </notes>
              </value>
            </enum>
            <description>The lens focus distance calibration quality.</description>
            <details>
            The lens focus distance calibration quality determines the reliability of
            focus related metadata entries, i.e. camera.lens.focusDistance,
            camera.lens.focusRange, camera.lens.info.hyperfocalDistance, and
            camera.lens.info.minimumFocusDistance.

            APPROXIMATE and CALIBRATED devices report the focus metadata in
            units of diopters (1/meter), so `0.0f` represents focusing at infinity,
            and increasing positive numbers represent focusing closer and closer
            to the camera device. The focus distance control also uses diopters
            on these devices.

            UNCALIBRATED devices do not use units that are directly comparable
            to any real physical measurement, but `0.0f` still represents farthest
            focus, and camera.lens.info.minimumFocusDistance represents the
            nearest focus the device can achieve.
            </details>
            <hal_details>
            For devices advertise APPROXIMATE quality or higher, diopters 0 (infinity
            focus) must work. When autofocus is disabled (camera.af.mode == OFF)
            and the lens focus distance is set to 0 diopters
            (camera.lens.focusDistance == 0), the lens will move to focus at infinity
            and is stably focused at infinity even if the device tilts. It may take the
            lens some time to move; during the move the lens state should be MOVING and
            the output diopter value should be changing toward 0.
            </hal_details>
          <tag id="V1" />
        </entry>
        </namespace>
        <entry name="facing" type="byte" visibility="public" enum="true" hwlevel="legacy">
          <enum>
            <value>FRONT
            <notes>
              The camera device faces the same direction as the device's screen.
            </notes></value>
            <value>BACK
            <notes>
              The camera device faces the opposite direction as the device's screen.
            </notes></value>
          </enum>
          <description>Direction the camera faces relative to
          device screen.</description>
        </entry>
        <entry name="opticalAxisAngle" type="float"
        type_notes="degrees. First defines the angle of separation between the perpendicular to the screen and the camera optical axis. The second then defines the clockwise rotation of the optical axis from native device up."
        container="array">
          <array>
            <size>2</size>
          </array>
          <description>Relative angle of camera optical axis to the
          perpendicular axis from the display</description>
          <range>[0-90) for first angle, [0-360) for second</range>
          <details>Examples:

          (0,0) means that the camera optical axis
          is perpendicular to the display surface;

          (45,0) means that the camera points 45 degrees up when
          device is held upright;

          (45,90) means the camera points 45 degrees to the right when
          the device is held upright.

          Use FACING field to determine perpendicular outgoing
          direction</details>
          <tag id="FUTURE" />
        </entry>
        <entry name="position" type="float" container="array">
          <array>
            <size>3, location in mm, in the sensor coordinate
            system</size>
          </array>
          <description>Coordinates of camera optical axis on
          device</description>
          <tag id="FUTURE" />
        </entry>
      </static>
      <dynamic>
        <clone entry="camera.lens.aperture" kind="controls">
          <tag id="V1" />
        </clone>
        <clone entry="camera.lens.filterDensity" kind="controls">
          <tag id="V1" />
        </clone>
        <clone entry="camera.lens.focalLength" kind="controls">
          <tag id="BC" />
        </clone>
        <clone entry="camera.lens.focusDistance" kind="controls">
          <details>Should be zero for fixed-focus cameras</details>
          <tag id="BC" />
        </clone>
        <entry name="focusRange" type="float" visibility="public"
        type_notes="Range of scene distances that are in focus"
        container="array" typedef="pairFloatFloat" hwlevel="limited">
          <array>
            <size>2</size>
          </array>
          <description>The range of scene distances that are in
          sharp focus (depth of field).</description>
          <units>A pair of focus distances in diopters: (near,
          far); see camera.lens.info.focusDistanceCalibration for details.</units>
          <range>&amp;gt;=0</range>
          <details>If variable focus not supported, can still report
          fixed depth of field range</details>
          <tag id="BC" />
        </entry>
        <clone entry="camera.lens.opticalStabilizationMode"
        kind="controls">
          <tag id="V1" />
        </clone>
        <entry name="state" type="byte" visibility="public" enum="true" hwlevel="limited">
          <enum>
            <value>STATIONARY
              <notes>
              The lens parameters (camera.lens.focalLength, camera.lens.focusDistance,
              camera.lens.filterDensity and camera.lens.aperture) are not changing.
              </notes>
            </value>
            <value>MOVING
              <notes>
              One or several of the lens parameters
              (camera.lens.focalLength, camera.lens.focusDistance,
              camera.lens.filterDensity or camera.lens.aperture) is
              currently changing.
              </notes>
            </value>
          </enum>
          <description>Current lens status.</description>
          <details>
          For lens parameters camera.lens.focalLength, camera.lens.focusDistance,
          camera.lens.filterDensity and camera.lens.aperture, when changes are requested,
          they may take several frames to reach the requested values. This state indicates
          the current status of the lens parameters.

          When the state is STATIONARY, the lens parameters are not changing. This could be
          either because the parameters are all fixed, or because the lens has had enough
          time to reach the most recently-requested values.
          If all these lens parameters are not changable for a camera device, as listed below:

          * Fixed focus (`camera.lens.info.minimumFocusDistance == 0`), which means
          camera.lens.focusDistance parameter will always be 0.
          * Fixed focal length (camera.lens.info.availableFocalLengths contains single value),
          which means the optical zoom is not supported.
          * No ND filter (camera.lens.info.availableFilterDensities contains only 0).
          * Fixed aperture (camera.lens.info.availableApertures contains single value).

          Then this state will always be STATIONARY.

          When the state is MOVING, it indicates that at least one of the lens parameters
          is changing.
          </details>
          <tag id="V1" />
        </entry>
      </dynamic>
    </section>
    <section name="noiseReduction">
      <controls>
        <entry name="mode" type="byte" visibility="public" enum="true" hwlevel="full">
          <enum>
            <value>OFF
            <notes>No noise reduction is applied.</notes></value>
            <value>FAST
            <notes>Noise reduction is applied without reducing frame rate relative to sensor
            output.</notes></value>
            <value>HIGH_QUALITY
            <notes>High-quality noise reduction is applied, at the cost of reducing frame rate
            relative to sensor output.</notes></value>
          </enum>
          <description>Mode of operation for the noise reduction algorithm.</description>
          <range>camera.noiseReduction.availableNoiseReductionModes</range>
          <details>The noise reduction algorithm attempts to improve image quality by removing
          excessive noise added by the capture process, especially in dark conditions.
          OFF means no noise reduction will be applied by the camera device.

          FAST/HIGH_QUALITY both mean camera device determined noise filtering
          will be applied. HIGH_QUALITY mode indicates that the camera device
          will use the highest-quality noise filtering algorithms,
          even if it slows down capture rate. FAST means the camera device will not
          slow down capture rate when applying noise filtering.
          </details>
          <tag id="V1" />
        </entry>
        <entry name="strength" type="byte">
          <description>Control the amount of noise reduction
          applied to the images</description>
          <units>1-10; 10 is max noise reduction</units>
          <range>1 - 10</range>
          <tag id="FUTURE" />
        </entry>
      </controls>
      <static>
        <entry name="availableNoiseReductionModes" type="byte" visibility="public"
        type_notes="list of enums" container="array" typedef="enumList" hwlevel="limited">
          <array>
            <size>n</size>
          </array>
          <description>
          List of noise reduction modes for camera.noiseReduction.mode that are supported
          by this camera device.
          </description>
          <range>Any value listed in camera.noiseReduction.mode</range>
          <details>
          Full-capability camera devices will always support OFF and FAST.

          Legacy-capability camera devices will only support FAST mode.
          </details>
          <tag id="V1" />
        </entry>
      </static>
      <dynamic>
        <clone entry="camera.noiseReduction.mode" kind="controls">
          <tag id="V1" />
        </clone>
      </dynamic>
    </section>
    <section name="request">
      <controls>
        <entry name="id" type="int32" visibility="hidden">
          <description>An application-specified ID for the current
          request. Must be maintained unchanged in output
          frame</description>
          <units>arbitrary integer assigned by application</units>
          <range>Any int</range>
          <tag id="V1" />
          <tag id="HALV3" />
        </entry>
        <entry name="metadataMode" type="byte" visibility="system"
               enum="true">
          <enum>
            <value>NONE
            <notes>No metadata should be produced on output, except
            for application-bound buffer data. If no
            application-bound streams exist, no frame should be
            placed in the output frame queue. If such streams
            exist, a frame should be placed on the output queue
            with null metadata but with the necessary output buffer
            information. Timestamp information should still be
            included with any output stream buffers</notes></value>
            <value>FULL
            <notes>All metadata should be produced. Statistics will
            only be produced if they are separately
            enabled</notes></value>
          </enum>
          <description>How much metadata to produce on
          output</description>
          <tag id="HALV3" />
        </entry>
      </controls>
      <static>
        <entry name="maxNumOutputStreams" type="int32" visibility="hidden"
        container="array" hwlevel="legacy">
          <array>
            <size>3</size>
          </array>
          <description>The maximum numbers of different types of output streams
          that can be configured and used simultaneously by a camera device.
          </description>
          <range>
          For processed (and stalling) format streams, &amp;gt;= 1.

          For Raw format (either stalling or non-stalling) streams, &amp;gt;= 0.

          For processed (but not stalling) format streams, &amp;gt;= 3
          for FULL mode devices (`camera.info.supportedHardwareLevel == FULL`);
          &amp;gt;= 2 for LIMITED mode devices (`camera.info.supportedHardwareLevel == LIMITED`).
          </range>
          <details>
          This is a 3 element tuple that contains the max number of output simultaneous
          streams for raw sensor, processed (but not stalling), and processed (and stalling)
          formats respectively. For example, assuming that JPEG is typically a processed and
          stalling stream, if max raw sensor format output stream number is 1, max YUV streams
          number is 3, and max JPEG stream number is 2, then this tuple should be `(1, 3, 2)`.

          This lists the upper bound of the number of output streams supported by
          the camera device. Using more streams simultaneously may require more hardware and
          CPU resources that will consume more power. The image format for an output stream can
          be any supported format provided by camera.scaler.availableStreamConfigurations.
          The formats defined in camera.scaler.availableStreamConfigurations can be catergorized
          into the 3 stream types as below:

          * Processed (but stalling): any non-RAW format with a stallDurations &amp;gt; 0.
          Typically JPEG format (ImageFormat#JPEG).
          * Raw formats: ImageFormat#RAW_SENSOR, ImageFormat#RAW10 and ImageFormat#RAW_OPAQUE.
          * Processed (but not-stalling): any non-RAW format without a stall duration.
          Typically ImageFormat#YUV_420_888, ImageFormat#NV21, ImageFormat#YV12.
          </details>
          <tag id="BC" />
          <tag id="HALV3" />
        </entry>
        <entry name="maxNumInputStreams" type="int32" visibility="hidden" hwlevel="full">
          <description>
          The maximum numbers of any type of input streams
          that can be configured and used simultaneously by a camera device.
          </description>
          <range>
          0 or 1.
          </range>
          <details>When set to 0, it means no input stream is supported.

          The image format for a input stream can be any supported
          format provided by
          camera.scaler.availableInputOutputFormatsMap. When using an
          input stream, there must be at least one output stream
          configured to to receive the reprocessed images.

          For example, for Zero Shutter Lag (ZSL) still capture use case, the input
          stream image format will be RAW_OPAQUE, the associated output stream image format
          should be JPEG.
          </details>
        </entry>
      </static>
      <dynamic>
        <clone entry="camera.request.id" kind="controls"></clone>
        <clone entry="camera.request.metadataMode"
        kind="controls"></clone>
        <entry name="pipelineDepth" type="byte" visibility="public" hwlevel="legacy">
          <description>Specifies the number of pipeline stages the frame went
          through from when it was exposed to when the final completed result
          was available to the framework.</description>
          <range>&amp;lt;= camera.request.pipelineMaxDepth</range>
          <details>Depending on what settings are used in the request, and
          what streams are configured, the data may undergo less processing,
          and some pipeline stages skipped.

          See camera.request.pipelineMaxDepth for more details.
          </details>
          <hal_details>
          This value must always represent the accurate count of how many
          pipeline stages were actually used.
          </hal_details>
        </entry>
      </dynamic>
      <static>
        <entry name="pipelineMaxDepth" type="byte" visibility="public" hwlevel="legacy">
          <description>Specifies the number of maximum pipeline stages a frame
          has to go through from when it's exposed to when it's available
          to the framework.</description>
          <details>A typical minimum value for this is 2 (one stage to expose,
          one stage to readout) from the sensor. The ISP then usually adds
          its own stages to do custom HW processing. Further stages may be
          added by SW processing.

          Depending on what settings are used (e.g. YUV, JPEG) and what
          processing is enabled (e.g. face detection), the actual pipeline
          depth (specified by camera.request.pipelineDepth) may be less than
          the max pipeline depth.

          A pipeline depth of X stages is equivalent to a pipeline latency of
          X frame intervals.

          This value will be 8 or less.
          </details>
          <hal_details>
          This value should be 4 or less.
          </hal_details>
          <tag id="HALV3" />
        </entry>
        <entry name="partialResultCount" type="int32" visibility="public" optional="true">
          <description>Defines how many sub-components
          a result will be composed of.
          </description>
          <range>&amp;gt;= 1</range>
          <details>In order to combat the pipeline latency, partial results
          may be delivered to the application layer from the camera device as
          soon as they are available.

          Optional; defaults to 1. A value of 1 means that partial
          results are not supported, and only the final TotalCaptureResult will
          be produced by the camera device.

          A typical use case for this might be: after requesting an
          auto-focus (AF) lock the new AF state might be available 50%
          of the way through the pipeline.  The camera device could
          then immediately dispatch this state via a partial result to
          the application, and the rest of the metadata via later
          partial results.
          </details>
          <tag id="HALV3" />
        </entry>
        <entry name="availableCapabilities" type="byte" visibility="public"
          enum="true" container="array" hwlevel="legacy">
          <array>
            <size>n</size>
          </array>
          <enum>
            <value>BACKWARD_COMPATIBLE
              <notes>The minimal set of capabilities that every camera
                device (regardless of camera.info.supportedHardwareLevel)
                supports.

                This capability is listed by all devices, and
                indicates that the camera device has a feature set
                that's comparable to the baseline requirements for the
                older camera.hardware.Camera API.
              </notes>
            </value>
            <value optional="true">MANUAL_SENSOR
              <notes>
              The camera device can be manually controlled (3A algorithms such
              as auto-exposure, and auto-focus can be bypassed).
              The camera device supports basic manual control of the sensor image
              acquisition related stages. This means the following controls are
              guaranteed to be supported:

              * Manual frame duration control
                  * camera.sensor.frameDuration
                  * camera.sensor.info.maxFrameDuration
              * Manual exposure control
                  * camera.sensor.exposureTime
                  * camera.sensor.info.exposureTimeRange
              * Manual sensitivity control
                  * camera.sensor.sensitivity
                  * camera.sensor.info.sensitivityRange
              * Manual lens control (if the lens is adjustable)
                  * camera.lens.*
              * Manual flash control (if a flash unit is present)
                  * camera.flash.*
              * Manual black level locking
                  * camera.blackLevel.lock

              If any of the above 3A algorithms are enabled, then the camera
              device will accurately report the values applied by 3A in the
              result.

              A given camera device may also support additional manual sensor controls,
              but this capability only covers the above list of controls.
              </notes>
            </value>
            <value optional="true">MANUAL_POST_PROCESSING
              <notes>
              The camera device post-processing stages can be manually controlled.
              The camera device supports basic manual control of the image post-processing
              stages. This means the following controls are guaranteed to be supported:

              * Manual tonemap control
                    * camera.tonemap.curve
                    * camera.tonemap.mode
                    * camera.tonemap.maxCurvePoints
              * Manual white balance control
                  * camera.awb.colorTransform
                  * camera.awb.colorGains
              * Manual lens shading map control
                    * camera.shading.mode
                    * camera.statistics.lensShadingMapMode
                    * camera.statistics.lensShadingMap
                    * camera.lens.info.shadingMapSize

              If auto white balance is enabled, then the camera device
              will accurately report the values applied by AWB in the result.

              A given camera device may also support additional post-processing
              controls, but this capability only covers the above list of controls.
              </notes>
            </value>
            <value optional="true">RAW
              <notes>
              The camera device supports outputting RAW buffers and
              metadata for interpreting them.

              Devices supporting the RAW capability allow both for
              saving DNG files, and for direct application processing of
              raw sensor images.

              * RAW_SENSOR is supported as an output format.
              * The maximum available resolution for RAW_SENSOR streams
                will match either the value in
                camera.sensor.info.pixelArraySize or
                camera.sensor.info.activeArraySize.
              * All DNG-related optional metadata entries are provided
                by the camera device.
              </notes>
            </value>
            <value optional="true" hidden="true">ZSL
              <notes>
              The camera device supports the Zero Shutter Lag use case.

              * At least one input stream can be used.
              * RAW_OPAQUE is supported as an output/input format
              * Using RAW_OPAQUE does not cause a frame rate drop
                relative to the sensor's maximum capture rate (at that
                resolution).
              * RAW_OPAQUE will be reprocessable into both YUV_420_888
                and JPEG formats.
              * The maximum available resolution for RAW_OPAQUE streams
                (both input/output) will match the maximum available
                resolution of JPEG streams.
              </notes>
            </value>
            <value optional="true">READ_SENSOR_SETTINGS
              <notes>
              The camera device supports accurately reporting the sensor settings for many of
              the sensor controls while the built-in 3A algorithm is running.  This allows
              reporting of sensor settings even when these settings cannot be manually changed.

              The values reported for the following controls are guaranteed to be available
              in the CaptureResult, including when 3A is enabled:

              * Exposure control
                  * camera.sensor.exposureTime
              * Sensitivity control
                  * camera.sensor.sensitivity
              * Lens controls (if the lens is adjustable)
                  * camera.lens.focusDistance
                  * camera.lens.aperture

              This capability is a subset of the MANUAL_SENSOR control capability, and will
              always be included if the MANUAL_SENSOR capability is available.
              </notes>
            </value>
            <value optional="true">BURST_CAPTURE
              <notes>
              The camera device supports capturing maximum-resolution
              images at &gt;= 20 frames per second, in at least the
              uncompressed YUV format, when post-processing settings
              are set to FAST.

              More specifically, this means that a size matching the
              camera device's active array size is listed as a
              supported size for the YUV format in
              camera.scaler.availableStreamConfigurations, the minimum frame
              duration for that format and size is &lt;= 1/20 s, and
              the camera.scaler.availableStreamConfigurations entry
              lists at least one FPS range for the maximum-size
              YUV format.

              In addition, the camera.sync.maxLatency field is
              guaranted to have a value between 0 and 4, inclusive.
              </notes>
            </value>
          </enum>
          <description>List of capabilities that this camera device
          advertises as fully supporting.</description>
          <details>
          A capability is a contract that the camera device makes in order
          to be able to satisfy one or more use cases.

          Listing a capability guarantees that the whole set of features
          required to support a common use will all be available.

          Using a subset of the functionality provided by an unsupported
          capability may be possible on a specific camera device implementation;
          to do this query each of camera.request.availableRequestKeys,
          camera.request.availableResultKeys,
          camera.request.availableCharacteristicsKeys.

          The following capabilities are guaranteed to be available on
          camera.info.supportedHardwareLevel `==` FULL devices:

          * MANUAL_SENSOR
          * MANUAL_POST_PROCESSING

          Other capabilities may be available on either FULL or LIMITED
          devices, but the application should query this key to be sure.
          </details>
          <hal_details>
          Additional constraint details per-capability will be available
          in the Compatibility Test Suite.

          Minimum baseline requirements required for the
          BACKWARD_COMPATIBLE capability are not explicitly listed.
          Instead refer to "BC" tags and the camera CTS tests in the
          camera.hardware.camera2.cts package.

          Listed controls that can be either request or result (e.g.
          camera.sensor.exposureTime) must be available both in the
          request and the result in order to be considered to be
          capability-compliant.

          For example, if the HAL claims to support MANUAL control,
          then exposure time must be configurable via the request _and_
          the actual exposure applied must be available via
          the result.

          If MANUAL_SENSOR is omitted, the HAL may choose to omit the
          camera.scaler.availableMinFrameDurations static property entirely.
          </hal_details>
          <tag id="HALV3" />
        </entry>
        <entry name="availableRequestKeys" type="int32" visibility="hidden"
          container="array" hwlevel="legacy">
          <array>
            <size>n</size>
          </array>
          <description>A list of all keys that the camera device has available
          to use with CaptureRequest.</description>

          <details>Attempting to set a key into a CaptureRequest that is not
          listed here will result in an invalid request and will be rejected
          by the camera device.

          This field can be used to query the feature set of a camera device
          at a more granular level than capabilities. This is especially
          important for optional keys that are not listed under any capability
          in camera.request.availableCapabilities.
          </details>
          <hal_details>
          Vendor tags must not be listed here. Use the vendor tag metadata
          extensions C api instead (refer to camera3.h for more details).

          Setting/getting vendor tags will be checked against the metadata
          vendor extensions API and not against this field.

          The HAL must not consume any request tags that are not listed either
          here or in the vendor tag list.

          The public camera2 API will always make the vendor tags visible
          via CameraCharacteristics#getAvailableCaptureRequestKeys.
          </hal_details>
          <tag id="HALV3" />
        </entry>
        <entry name="availableResultKeys" type="int32" visibility="hidden"
          container="array" hwlevel="legacy">
          <array>
            <size>n</size>
          </array>
          <description>A list of all keys that the camera device has available
          to use with CaptureResult.</description>

          <details>Attempting to get a key from a CaptureResult that is not
          listed here will always return a `null` value. Getting a key from
          a CaptureResult that is listed here will generally never return a `null`
          value.

          The following keys may return `null` unless they are enabled:

          * camera.statistics.lensShadingMap (non-null iff camera.statistics.lensShadingMapMode == ON)

          (Those sometimes-null keys will nevertheless be listed here
          if they are available.)

          This field can be used to query the feature set of a camera device
          at a more granular level than capabilities. This is especially
          important for optional keys that are not listed under any capability
          in camera.request.availableCapabilities.
          </details>
          <hal_details>
          Tags listed here must always have an entry in the result metadata,
          even if that size is 0 elements. Only array-type tags (e.g. lists,
          matrices, strings) are allowed to have 0 elements.

          Vendor tags must not be listed here. Use the vendor tag metadata
          extensions C api instead (refer to camera3.h for more details).

          Setting/getting vendor tags will be checked against the metadata
          vendor extensions API and not against this field.

          The HAL must not produce any result tags that are not listed either
          here or in the vendor tag list.

          The public camera2 API will always make the vendor tags visible
          via CameraCharacteristics#getAvailableCaptureResultKeys.
          </hal_details>
          <tag id="HALV3" />
        </entry>
        <entry name="availableCharacteristicsKeys" type="int32" visibility="hidden"
          container="array" hwlevel="legacy">
          <array>
            <size>n</size>
          </array>
          <description>A list of all keys that the camera device has available
          to use with CameraCharacteristics.</description>
          <details>This entry follows the same rules as
          camera.request.availableResultKeys (except that it applies for
          CameraCharacteristics instead of CaptureResult). See above for more
          details.
          </details>
          <hal_details>
          Keys listed here must always have an entry in the static info metadata,
          even if that size is 0 elements. Only array-type tags (e.g. lists,
          matrices, strings) are allowed to have 0 elements.

          Vendor tags must not be listed here. Use the vendor tag metadata
          extensions C api instead (refer to camera3.h for more details).

          Setting/getting vendor tags will be checked against the metadata
          vendor extensions API and not against this field.

          The HAL must not have any tags in its static info that are not listed
          either here or in the vendor tag list.

          The public camera2 API will always make the vendor tags visible
          via CameraCharacteristics#getKeys.
          </hal_details>
        </entry>
      </static>
    </section>
    <section name="scaler">
      <controls>
        <entry name="cropRegion" type="int32" visibility="public"
               container="array" typedef="rectangle" hwlevel="legacy">
          <array>
            <size>4</size>
          </array>
          <description>The desired region of the sensor to read out for this capture.</description>
          <units>Pixel coordinates relative to
          camera.sensor.info.activeArraySize</units>
          <details>
            This control can be used to implement digital zoom.

            The crop region coordinate system is based off
            camera.sensor.info.activeArraySize, with `(0, 0)` being the
            top-left corner of the sensor active array.

            Output streams use this rectangle to produce their output,
            cropping to a smaller region if necessary to maintain the
            stream's aspect ratio, then scaling the sensor input to
            match the output's configured resolution.

            The crop region is applied after the RAW to other color
            space (e.g. YUV) conversion. Since raw streams
            (e.g. RAW16) don't have the conversion stage, they are not
            croppable. The crop region will be ignored by raw streams.

            For non-raw streams, any additional per-stream cropping will
            be done to maximize the final pixel area of the stream.

            For example, if the crop region is set to a 4:3 aspect
            ratio, then 4:3 streams will use the exact crop
            region. 16:9 streams will further crop vertically
            (letterbox).

            Conversely, if the crop region is set to a 16:9, then 4:3
            outputs will crop horizontally (pillarbox), and 16:9
            streams will match exactly. These additional crops will
            be centered within the crop region.

            The width and height of the crop region cannot
            be set to be smaller than
            `floor( activeArraySize.width / camera.scaler.availableMaxDigitalZoom )` and
            `floor( activeArraySize.height / camera.scaler.availableMaxDigitalZoom )`, respectively.

            The camera device may adjust the crop region to account
            for rounding and other hardware requirements; the final
            crop region used will be included in the output capture
            result.
          </details>
          <hal_details>
            The output streams must maintain square pixels at all
            times, no matter what the relative aspect ratios of the
            crop region and the stream are.  Negative values for
            corner are allowed for raw output if full pixel array is
            larger than active pixel array. Width and height may be
            rounded to nearest larger supportable width, especially
            for raw output, where only a few fixed scales may be
            possible.

            HAL2.x uses only (x, y, width)
          </hal_details>
          <tag id="BC" />
        </entry>
      </controls>
      <static>
        <entry name="availableJpegSizes" type="int32" visibility="hidden"
        deprecated="true" container="array" typedef="size">
          <array>
            <size>n</size>
            <size>2</size>
          </array>
          <description>The JPEG resolutions that are supported by this camera device.</description>
          <range>TODO: Remove property.</range>
          <details>
          The resolutions are listed as `(width, height)` pairs. All camera devices will support
          sensor maximum resolution (defined by camera.sensor.info.activeArraySize).
          </details>
          <hal_details>
          The HAL must include sensor maximum resolution
          (defined by camera.sensor.info.activeArraySize),
          and should include half/quarter of sensor maximum resolution.
          </hal_details>
          <tag id="BC" />
          <tag id="HALV3" />
        </entry>
        <entry name="availableMaxDigitalZoom" type="float" visibility="public"
              hwlevel="legacy">
          <description>The maximum ratio between both active area width
          and crop region width, and active area height and
          crop region height, for camera.scaler.cropRegion.
          </description>
          <units>Zoom scale factor</units>
          <range>&amp;gt;=1</range>
          <details>
          This represents the maximum amount of zooming possible by
          the camera device, or equivalently, the minimum cropping
          window size.

          Crop regions that have a width or height that is smaller
          than this ratio allows will be rounded up to the minimum
          allowed size by the camera device.
          </details>
          <tag id="BC" />
        </entry>
      </static>
      <dynamic>
        <clone entry="camera.scaler.cropRegion" kind="controls">
        </clone>
      </dynamic>
      <static>
        <entry name="availableInputOutputFormatsMap" type="int32"
        visibility="hidden"
        container="array" typedef="imageFormat"
        hwlevel="full">
          <array>
            <size>n</size>
          </array>
          <description>The mapping of image formats that are supported by this
          camera device for input streams, to their corresponding output formats.
          </description>
          <details>
          All camera devices with at least 1
          camera.request.maxNumInputStreams will have at least one
          available input format.

          Attempting to configure an input stream with output streams not
          listed as available in this map is not valid.

          TODO: typedef to ReprocessFormatMap
          </details>
          <hal_details>
          For the formats, see `system/core/include/system/graphics.h` for a definition
          of the image format enumerations.

          This value is encoded as a variable-size array-of-arrays.
          The inner array always contains `[format, length, ...]` where
          `...` has `length` elements. An inner array is followed by another
          inner array if the total metadata entry size hasn't yet been exceeded.

          A code sample to read/write this encoding (with a device that
          supports reprocessing RAW_OPAQUE to RAW16, YUV_420_888, and JPEG,
          and reprocessing RAW16 to YUV_420_888 and JPEG):

              // reading
              int32_t* contents = &amp;entry.i32[0];
              for (size_t i = 0; i &lt; entry.count; ) {
                  int32_t format = contents[i++];
                  int32_t length = contents[i++];
                  int32_t output_formats[length];
                  memcpy(&amp;output_formats[0], &amp;contents[i],
                         length * sizeof(int32_t));
                  i += length;
              }

              // writing (static example, RAW+ZSL)
              int32_t[] contents = {
                RAW_OPAQUE, 3, RAW16, YUV_420_888, BLOB,
                RAW16, 2, YUV_420_888, BLOB,
              };
              update_icamera_metadata_entry(metadata, index, &amp;contents[0],
                    sizeof(contents)/sizeof(contents[0]), &amp;updated_entry);

          If the HAL claims to support any of the capabilities listed in the
          above details, then it must also support all the input-output
          combinations listed for that capability. It can optionally support
          additional formats if it so chooses.
          </hal_details>
          <tag id="HALV3" />
        </entry>
        <entry name="availableStreamConfigurations" type="int32" visibility="hidden"
          container="array"
          typedef="streamConfiguration" hwlevel="legacy">
          <array>
            <size>n</size>
            <size>8</size>
          </array>
          <description>The available stream configurations that this
          camera device supports
          (i.e. format, width, height, field, reserved, reserved, maxVideoFps, maxCaptureFps).
          </description>
          <details>
          </details>
          <hal_details>
          </hal_details>
        </entry>
        <entry name="availableMinFrameDurations" type="int64" visibility="hidden"
               container="array"
               typedef="streamConfigurationDuration" hwlevel="legacy">
          <array>
            <size>4</size>
            <size>n</size>
          </array>
          <description>This lists the minimum frame duration for each
          format/size combination.
          </description>
          <units>(format, width, height, ns) x n</units>
          <details>
          This should correspond to the frame duration when only that
          stream is active, with all processing (typically in camera.*.mode)
          set to either OFF or FAST.

          When multiple streams are used in a request, the minimum frame
          duration will be max(individual stream min durations).

          The minimum frame duration of a stream (of a particular format, size)
          is the same regardless of whether the stream is input or output.

          See camera.sensor.frameDuration for more details about
          calculating the max frame rate.

          (Keep in sync with
          StreamConfigurationMap#getOutputMinFrameDuration)
          </details>
          <tag id="V1" />
          <tag id="HALV3" />
        </entry>
        <entry name="croppingType" type="byte" visibility="public" enum="true"
               hwlevel="legacy">
          <enum>
            <value>CENTER_ONLY
              <notes>
                The camera device only supports centered crop regions.
              </notes>
            </value>
            <value>FREEFORM
              <notes>
                The camera device supports arbitrarily chosen crop regions.
              </notes>
            </value>
          </enum>
          <description>The crop type that this camera device supports.</description>
          <details>
          When passing a non-centered crop region (camera.scaler.cropRegion) to a camera
          device that only supports CENTER_ONLY cropping, the camera device will move the
          crop region to the center of the sensor active array (camera.sensor.info.activeArraySize)
          and keep the crop region width and height unchanged. The camera device will return the
          final used crop region in metadata result camera.scaler.cropRegion.

          Camera devices that support FREEFORM cropping will support any crop region that
          is inside of the active array. The camera device will apply the same crop region and
          return the final used crop region in capture result metadata camera.scaler.cropRegion.

          FULL capability devices (camera.info.supportedHardwareLevel `==` FULL) will support
          FREEFORM cropping. LEGACY capability devices will only support CENTER_ONLY cropping.
          </details>
        </entry>
      </static>
    </section>
    <section name="sensor">
      <controls>
        <entry name="exposureTime" type="int64" visibility="public" hwlevel="full">
          <description>Duration each pixel is exposed to
          light.</description>
          <units>microseconds</units>
          <range>camera.sensor.info.exposureTimeRange</range>
          <details>If the sensor can't expose this exact duration, it will shorten the
          duration exposed to the nearest possible value (rather than expose longer).
          The final exposure time used will be available in the output capture result.

          This control is only effective if camera.ae.mode or camera.control.mode is set to
          OFF; otherwise the auto-exposure algorithm will override this value.
          </details>
          <tag id="V1" />
        </entry>
        <entry name="frameDuration" type="int64" visibility="public" hwlevel="full">
          <description>Duration from start of frame exposure to
          start of next frame exposure.</description>
          <units>Nanoseconds</units>
          <range>See camera.sensor.info.maxFrameDuration,
          camera.scaler.availableStreamConfigurations. The duration
          is capped to `max(duration, exposureTime + overhead)`.</range>
          <details>
          The maximum frame rate that can be supported by a camera subsystem is
          a function of many factors:

          * Requested resolutions of output image streams
          * Availability of binning / skipping modes on the imager
          * The bandwidth of the imager interface
          * The bandwidth of the various ISP processing blocks

          Since these factors can vary greatly between different ISPs and
          sensors, the camera abstraction tries to represent the bandwidth
          restrictions with as simple a model as possible.

          The model presented has the following characteristics:

          * The image sensor is always configured to output the smallest
          resolution possible given the application's requested output stream
          sizes.  The smallest resolution is defined as being at least as large
          as the largest requested output stream size; the camera pipeline must
          never digitally upsample sensor data when the crop region covers the
          whole sensor. In general, this means that if only small output stream
          resolutions are configured, the sensor can provide a higher frame
          rate.
          * Since any request may use any or all the currently configured
          output streams, the sensor and ISP must be configured to support
          scaling a single capture to all the streams at the same time.  This
          means the camera pipeline must be ready to produce the largest
          requested output size without any delay.  Therefore, the overall
          frame rate of a given configured stream set is governed only by the
          largest requested stream resolution.
          * Using more than one output stream in a request does not affect the
          frame duration.
          * Certain format-streams may need to do additional background processing
          before data is consumed/produced by that stream. These processors
          can run concurrently to the rest of the camera pipeline, but
          cannot process more than 1 capture at a time.

          The necessary information for the application, given the model above,
          is provided via the camera.scaler.availableStreamConfigurations field
          These are used to determine the maximum frame rate / minimum frame
          duration that is possible for a given stream configuration.

          Specifically, the application can use the following rules to
          determine the minimum frame duration it can request from the camera
          device:

          1. Let the set of currently configured input/output streams
          be called `S`.
          1. Find the minimum frame durations for each stream in `S`, by
          looking it up in camera.scaler.availableStreamConfigurations (with
          its respective size/format/field). Let this set of frame durations be called
          `F`.
          1. For any given request `R`, the minimum frame duration allowed
          for `R` is the maximum out of all values in `F`. Let the streams
          used in `R` be called `S_r`.

          If none of the streams in `S_r` have a stall time (listed in
          StreamConfigurationMap#getOutputStallDuration(int,Size) using its
          respective size/format), then the frame duration in
          `F` determines the steady state frame rate that the application will
          get if it uses `R` as a repeating request. Let this special kind
          of request be called `Rsimple`.

          A repeating request `Rsimple` can be _occasionally_ interleaved
          by a single capture of a new request `Rstall` (which has at least
          one in-use stream with a non-0 stall time) and if `Rstall` has the
          same minimum frame duration this will not cause a frame rate loss
          if all buffers from the previous `Rstall` have already been
          delivered.

          For more details about stalling, see
          StreamConfigurationMap#getOutputStallDuration(int,Size).

          This control is only effective if camera.ae.mode or camera.control.mode is set to
          OFF; otherwise the auto-exposure algorithm will override this value.
          </details>
          <tag id="V1" />
        </entry>
        <entry name="sensitivity" type="int32" visibility="public" hwlevel="full">
          <description>The amount of gain applied to sensor data
          before processing.</description>
          <units>ISO arithmetic units</units>
          <range>camera.sensor.info.sensitivityRange</range>
          <details>
          The sensitivity is the standard ISO sensitivity value,
          as defined in ISO 12232:2006.

          The sensitivity must be within camera.sensor.info.sensitivityRange, and
          if if it less than camera.sensor.maxAnalogSensitivity, the camera device
          is guaranteed to use only analog amplification for applying the gain.

          If the camera device cannot apply the exact sensitivity
          requested, it will reduce the gain to the nearest supported
          value. The final sensitivity used will be available in the
          output capture result.
          </details>
          <hal_details>ISO 12232:2006 REI method is acceptable.</hal_details>
          <tag id="V1" />
        </entry>
      </controls>
      <static>
        <namespace name="info">
          <entry name="activeArraySize" type="int32" visibility="public"
          type_notes="Four ints defining the active pixel rectangle"
          container="array"
          typedef="rectangle"
          hwlevel="legacy">
            <array>
              <size>4</size>
            </array>
            <description>The area of the image sensor which corresponds to
            active pixels.</description>
            <units>Pixel coordinates on the image sensor</units>
            <range>
            </range>
            <details>
            This is the region of the sensor that actually receives light from the scene.
            Therefore, the size of this region determines the maximum field of view and the maximum
            number of pixels that an image from this sensor can contain.

            The rectangle is defined in terms of the full pixel array; (0,0) is the top-left of the
            full pixel array, and the size of the full pixel array is given by
            camera.sensor.info.pixelArraySize.

            Most other keys listing pixel coordinates have their coordinate systems based on the
            active array, with `(0, 0)` being the top-left of the active array rectangle.

            The active array may be smaller than the full pixel array, since the full array may
            include black calibration pixels or other inactive regions.
            </details>
            <hal_details>
            This array contains `(xmin, ymin, width, height)`. The `(xmin, ymin)` must be
            &amp;gt;= `(0,0)`.
            The `(width, height)` must be &amp;lt;= `camera.sensor.info.pixelArraySize`.
            </hal_details>
            <tag id="RAW" />
            <tag id="HALV3" />
          </entry>
          <entry name="sensitivityRange" type="int32" visibility="public"
          type_notes="Range of supported sensitivities"
          container="array" typedef="rangeInt"
          hwlevel="full">
            <array>
              <size>2</size>
            </array>
            <description>Range of sensitivities for camera.sensor.sensitivity supported by this
            camera device.</description>
            <range>Min &lt;= 100, Max &amp;gt;= 800</range>
            <details>
              The values are the standard ISO sensitivity values,
              as defined in ISO 12232:2006.
            </details>

            <tag id="BC" />
            <tag id="V1" />
          </entry>
          <entry name="colorFilterArrangement" type="byte" visibility="public" enum="true"
            hwlevel="full">
            <enum>
              <value>RGGB</value>
              <value>GRBG</value>
              <value>GBRG</value>
              <value>BGGR</value>
              <value>RGB
              <notes>Sensor is not Bayer; output has 3 16-bit
              values for each pixel, instead of just 1 16-bit value
              per pixel.</notes></value>
            </enum>
            <description>The arrangement of color filters on sensor;
            represents the colors in the top-left 2x2 section of
            the sensor, in reading order.</description>
            <tag id="RAW" />
          </entry>
          <entry name="exposureTimeRange" type="int64" visibility="public"
                 type_notes="microseconds" container="array" typedef="rangeLong"
                 hwlevel="full">
            <array>
              <size>2</size>
            </array>
            <description>The range of image exposure times for camera.sensor.exposureTime supported
            by this camera device.
            </description>
            <units>Nanoseconds</units>
            <range>The minimum exposure time will be less than 100 us. For FULL
            capability devices (camera.info.supportedHardwareLevel == FULL),
            the maximum exposure time will be greater than 100ms.</range>
            <hal_details>For FULL capability devices (camera.info.supportedHardwareLevel == FULL),
            The maximum of the range SHOULD be at least 1 second (1e9), MUST be at least
            100ms.
            </hal_details>
            <tag id="V1" />
          </entry>
          <entry name="maxFrameDuration" type="int64" visibility="public"
                 hwlevel="full">
            <description>The maximum possible frame duration (minimum frame rate) for
            camera.sensor.frameDuration that is supported this camera device.</description>
            <units>Nanoseconds</units>
            <range>For FULL capability devices
            (camera.info.supportedHardwareLevel == FULL), at least 100ms.
            </range>
            <details>Attempting to use frame durations beyond the maximum will result in the frame
            duration being clipped to the maximum. See that control for a full definition of frame
            durations.

            Refer to StreamConfigurationMap#getOutputMinFrameDuration(int,Size) for the minimum
            frame duration values.
            </details>
            <hal_details>
            For FULL capability devices (camera.info.supportedHardwareLevel == FULL),
            The maximum of the range SHOULD be at least
            1 second (1e9), MUST be at least 100ms (100e6).

            camera.sensor.info.maxFrameDuration must be greater or
            equal to the camera.sensor.info.exposureTimeRange max
            value (since exposure time overrides frame duration).

            Available minimum frame durations for JPEG must be no greater
            than that of the YUV_420_888/IMPLEMENTATION_DEFINED
            minimum frame durations (for that respective size).
            </hal_details>
            <tag id="V1" />
          </entry>
          <entry name="physicalSize" type="float" visibility="public"
          type_notes="width x height"
          container="array" typedef="sizeF" hwlevel="legacy">
            <array>
              <size>2</size>
            </array>
            <description>The physical dimensions of the full pixel
            array.</description>
            <units>Millimeters</units>
            <details>This is the physical size of the sensor pixel
            array defined by camera.sensor.info.pixelArraySize.
            </details>
            <hal_details>Needed for FOV calculation for old API</hal_details>
            <tag id="V1" />
            <tag id="BC" />
            <tag id="HALV3" />
          </entry>
          <entry name="pixelArraySize" type="int32" visibility="public"
          container="array" typedef="size" hwlevel="legacy">
            <array>
              <size>2</size>
            </array>
            <description>Dimensions of the full pixel array, possibly
            including black calibration pixels.</description>
            <units>Pixels</units>
            <details>The pixel count of the full pixel array,
            which covers camera.sensor.info.physicalSize area.

            If a camera device supports raw sensor formats, either this
            or camera.sensor.info.activeArraySize is the maximum output
            raw size listed in camera.scaler.availableStreamConfigurations.
            If a size corresponding to pixelArraySize is listed, the resulting
            raw sensor image will include black pixels.

            Some parts of the full pixel array may not receive light from the scene,
            or are otherwise inactive.  The camera.sensor.info.activeArraySize key
            defines the rectangle of active pixels that actually forms an image.
            </details>
            <tag id="RAW" />
            <tag id="BC" />
            <tag id="HALV3" />
          </entry>
          <entry name="whiteLevel" type="int32" visibility="public">
            <description>
            Maximum raw value output by sensor.
            </description>
            <range>&amp;gt; 255 (8-bit output)</range>
            <details>
            This specifies the fully-saturated encoding level for the raw
            sample values from the sensor.  This is typically caused by the
            sensor becoming highly non-linear or clipping. The minimum for
            each channel is specified by the offset in the
            camera.sensor.blackLevelPattern key.

            The white level is typically determined either by sensor bit depth
            (8-14 bits is expected), or by the point where the sensor response
            becomes too non-linear to be useful.  The default value for this is
            maximum representable value for a 16-bit raw sample (2^16 - 1).
            </details>
            <hal_details>
            The full bit depth of the sensor must be available in the raw data,
            so the value for linear sensors should not be significantly lower
            than maximum raw value supported, i.e. 2^(sensor bits per pixel).
            </hal_details>
            <tag id="RAW" />
          </entry>
          <entry name="timestampSource" type="byte" visibility="public"
                 enum="true" hwlevel="legacy">
            <enum>
              <value>UNKNOWN
                <notes>
                Timestamps from camera.sensor.timestamp are in nanoseconds and monotonic,
                but can not be compared to timestamps from other subsystems
                (e.g. accelerometer, gyro etc.), or other instances of the same or different
                camera devices in the same system. Timestamps between streams and results for
                a single camera instance are comparable, and the timestamps for all buffers
                and the result metadata generated by a single capture are identical.
                </notes>
              </value>
              <value>REALTIME
                <notes>
                Timestamps from camera.sensor.timestamp are in the same timebase as
                camera.os.SystemClock#elapsedRealtimeNanos(),
                and they can be compared to other timestamps using that base.
                </notes>
              </value>
            </enum>
            <description>The time base source for sensor capture start timestamps.</description>
            <details>
            The timestamps provided for captures are always in nanoseconds and monotonic, but
            may not based on a time source that can be compared to other system time sources.

            This characteristic defines the source for the timestamps, and therefore whether they
            can be compared against other system time sources/timestamps.
            </details>
          <tag id="V1" />
          <tag id="HALV3" />
        </entry>
        </namespace>
        <entry name="referenceIlluminant1" type="byte" visibility="public"
               enum="true">
          <enum>
            <value id="1">DAYLIGHT</value>
            <value id="2">FLUORESCENT</value>
            <value id="3">TUNGSTEN
              <notes>Incandescent light</notes>
            </value>
            <value id="4">FLASH</value>
            <value id="9">FINE_WEATHER</value>
            <value id="10">CLOUDY_WEATHER</value>
            <value id="11">SHADE</value>
            <value id="12">DAYLIGHT_FLUORESCENT
              <notes>D 5700 - 7100K</notes>
            </value>
            <value id="13">DAY_WHITE_FLUORESCENT
              <notes>N 4600 - 5400K</notes>
            </value>
            <value id="14">COOL_WHITE_FLUORESCENT
              <notes>W 3900 - 4500K</notes>
            </value>
            <value id="15">WHITE_FLUORESCENT
              <notes>WW 3200 - 3700K</notes>
            </value>
            <value id="17">STANDARD_A</value>
            <value id="18">STANDARD_B</value>
            <value id="19">STANDARD_C</value>
            <value id="20">D55</value>
            <value id="21">D65</value>
            <value id="22">D75</value>
            <value id="23">D50</value>
            <value id="24">ISO_STUDIO_TUNGSTEN</value>
          </enum>
          <description>
          The standard reference illuminant used as the scene light source when
          calculating the camera.sensor.colorTransform1,
          camera.sensor.calibrationTransform1, and
          camera.sensor.forwardMatrix1 matrices.
          </description>
          <details>
          The values in this key correspond to the values defined for the
          EXIF LightSource tag. These illuminants are standard light sources
          that are often used calibrating camera devices.

          If this key is present, then camera.sensor.colorTransform1,
          camera.sensor.calibrationTransform1, and
          camera.sensor.forwardMatrix1 will also be present.

          Some devices may choose to provide a second set of calibration
          information for improved quality, including
          camera.sensor.referenceIlluminant2 and its corresponding matrices.
          </details>
          <hal_details>
          The first reference illuminant (camera.sensor.referenceIlluminant1)
          and corresponding matrices must be present to support the RAW capability
          and DNG output.

          When producing raw images with a color profile that has only been
          calibrated against a single light source, it is valid to omit
          camera.sensor.referenceIlluminant2 along with the
          camera.sensor.colorTransform2, camera.sensor.calibrationTransform2,
          and camera.sensor.forwardMatrix2 matrices.

          If only camera.sensor.referenceIlluminant1 is included, it should be
          chosen so that it is representative of typical scene lighting.  In
          general, D50 or DAYLIGHT will be chosen for this case.

          If both camera.sensor.referenceIlluminant1 and
          camera.sensor.referenceIlluminant2 are included, they should be
          chosen to represent the typical range of scene lighting conditions.
          In general, low color temperature illuminant such as Standard-A will
          be chosen for the first reference illuminant and a higher color
          temperature illuminant such as D65 will be chosen for the second
          reference illuminant.
          </hal_details>
          <tag id="RAW" />
        </entry>
        <entry name="referenceIlluminant2" type="byte" visibility="public">
          <description>
          The standard reference illuminant used as the scene light source when
          calculating the camera.sensor.colorTransform2,
          camera.sensor.calibrationTransform2, and
          camera.sensor.forwardMatrix2 matrices.
          </description>
          <range>Any value listed in camera.sensor.referenceIlluminant1</range>
          <details>
          See camera.sensor.referenceIlluminant1 for more details.

          If this key is present, then camera.sensor.colorTransform2,
          camera.sensor.calibrationTransform2, and
          camera.sensor.forwardMatrix2 will also be present.
          </details>
          <tag id="RAW" />
        </entry>
        <entry name="calibrationTransform1" type="rational"
        visibility="public" optional="true"
        type_notes="3x3 matrix in row-major-order" container="array"
        typedef="colorSpaceTransform">
          <array>
            <size>3</size>
            <size>3</size>
          </array>
          <description>
          A per-device calibration transform matrix that maps from the
          reference sensor colorspace to the actual device sensor colorspace.
          </description>
          <details>
          This matrix is used to correct for per-device variations in the
          sensor colorspace, and is used for processing raw buffer data.

          The matrix is expressed as a 3x3 matrix in row-major-order, and
          contains a per-device calibration transform that maps colors
          from reference sensor color space (i.e. the "golden module"
          colorspace) into this camera device's native sensor color
          space under the first reference illuminant
          (camera.sensor.referenceIlluminant1).
          </details>
          <tag id="RAW" />
        </entry>
        <entry name="calibrationTransform2" type="rational"
        visibility="public" optional="true"
        type_notes="3x3 matrix in row-major-order" container="array"
        typedef="colorSpaceTransform">
          <array>
            <size>3</size>
            <size>3</size>
          </array>
          <description>
          A per-device calibration transform matrix that maps from the
          reference sensor colorspace to the actual device sensor colorspace
          (this is the colorspace of the raw buffer data).
          </description>
          <details>
          This matrix is used to correct for per-device variations in the
          sensor colorspace, and is used for processing raw buffer data.

          The matrix is expressed as a 3x3 matrix in row-major-order, and
          contains a per-device calibration transform that maps colors
          from reference sensor color space (i.e. the "golden module"
          colorspace) into this camera device's native sensor color
          space under the second reference illuminant
          (camera.sensor.referenceIlluminant2).

          This matrix will only be present if the second reference
          illuminant is present.
          </details>
          <tag id="RAW" />
        </entry>
        <entry name="colorTransform1" type="rational"
        visibility="public" optional="true"
        type_notes="3x3 matrix in row-major-order" container="array"
        typedef="colorSpaceTransform">
          <array>
            <size>3</size>
            <size>3</size>
          </array>
          <description>
          A matrix that transforms color values from CIE XYZ color space to
          reference sensor color space.
          </description>
          <details>
          This matrix is used to convert from the standard CIE XYZ color
          space to the reference sensor colorspace, and is used when processing
          raw buffer data.

          The matrix is expressed as a 3x3 matrix in row-major-order, and
          contains a color transform matrix that maps colors from the CIE
          XYZ color space to the reference sensor color space (i.e. the
          "golden module" colorspace) under the first reference illuminant
          (camera.sensor.referenceIlluminant1).

          The white points chosen in both the reference sensor color space
          and the CIE XYZ colorspace when calculating this transform will
          match the standard white point for the first reference illuminant
          (i.e. no chromatic adaptation will be applied by this transform).
          </details>
          <tag id="RAW" />
        </entry>
        <entry name="colorTransform2" type="rational"
        visibility="public" optional="true"
        type_notes="3x3 matrix in row-major-order" container="array"
        typedef="colorSpaceTransform">
          <array>
            <size>3</size>
            <size>3</size>
          </array>
          <description>
          A matrix that transforms color values from CIE XYZ color space to
          reference sensor color space.
          </description>
          <details>
          This matrix is used to convert from the standard CIE XYZ color
          space to the reference sensor colorspace, and is used when processing
          raw buffer data.

          The matrix is expressed as a 3x3 matrix in row-major-order, and
          contains a color transform matrix that maps colors from the CIE
          XYZ color space to the reference sensor color space (i.e. the
          "golden module" colorspace) under the second reference illuminant
          (camera.sensor.referenceIlluminant2).

          The white points chosen in both the reference sensor color space
          and the CIE XYZ colorspace when calculating this transform will
          match the standard white point for the second reference illuminant
          (i.e. no chromatic adaptation will be applied by this transform).

          This matrix will only be present if the second reference
          illuminant is present.
          </details>
          <tag id="RAW" />
        </entry>
        <entry name="forwardMatrix1" type="rational"
        visibility="public" optional="true"
        type_notes="3x3 matrix in row-major-order" container="array"
        typedef="colorSpaceTransform">
          <array>
            <size>3</size>
            <size>3</size>
          </array>
          <description>
          A matrix that transforms white balanced camera colors from the reference
          sensor colorspace to the CIE XYZ colorspace with a D50 whitepoint.
          </description>
          <details>
          This matrix is used to convert to the standard CIE XYZ colorspace, and
          is used when processing raw buffer data.

          This matrix is expressed as a 3x3 matrix in row-major-order, and contains
          a color transform matrix that maps white balanced colors from the
          reference sensor color space to the CIE XYZ color space with a D50 white
          point.

          Under the first reference illuminant (camera.sensor.referenceIlluminant1)
          this matrix is chosen so that the standard white point for this reference
          illuminant in the reference sensor colorspace is mapped to D50 in the
          CIE XYZ colorspace.
          </details>
          <tag id="RAW" />
        </entry>
        <entry name="forwardMatrix2" type="rational"
        visibility="public" optional="true"
        type_notes="3x3 matrix in row-major-order" container="array"
        typedef="colorSpaceTransform">
          <array>
            <size>3</size>
            <size>3</size>
          </array>
          <description>
          A matrix that transforms white balanced camera colors from the reference
          sensor colorspace to the CIE XYZ colorspace with a D50 whitepoint.
          </description>
          <details>
          This matrix is used to convert to the standard CIE XYZ colorspace, and
          is used when processing raw buffer data.

          This matrix is expressed as a 3x3 matrix in row-major-order, and contains
          a color transform matrix that maps white balanced colors from the
          reference sensor color space to the CIE XYZ color space with a D50 white
          point.

          Under the second reference illuminant (camera.sensor.referenceIlluminant2)
          this matrix is chosen so that the standard white point for this reference
          illuminant in the reference sensor colorspace is mapped to D50 in the
          CIE XYZ colorspace.

          This matrix will only be present if the second reference
          illuminant is present.
          </details>
          <tag id="RAW" />
        </entry>
        <entry name="baseGainFactor" type="rational"
        optional="true">
          <description>Gain factor from electrons to raw units when
          ISO=100</description>
          <tag id="FUTURE" />
        </entry>
        <entry name="blackLevelPattern" type="int32" visibility="public"
        optional="true" type_notes="2x2 raw count block" container="array"
        typedef="blackLevelPattern">
          <array>
            <size>4</size>
          </array>
          <description>
          A fixed black level offset for each of the color filter arrangement
          (CFA) mosaic channels.
          </description>
          <range>&amp;gt;= 0 for each.</range>
          <details>
          This key specifies the zero light value for each of the CFA mosaic
          channels in the camera sensor.  The maximal value output by the
          sensor is represented by the value in camera.sensor.info.whiteLevel.

          The values are given in the same order as channels listed for the CFA
          layout key (see camera.sensor.info.colorFilterArrangement), i.e. the
          nth value given corresponds to the black level offset for the nth
          color channel listed in the CFA.
          </details>
          <hal_details>
          The values are given in row-column scan order, with the first value
          corresponding to the element of the CFA in row=0, column=0.
          </hal_details>
          <tag id="RAW" />
        </entry>
        <entry name="maxAnalogSensitivity" type="int32" visibility="public"
               optional="true" hwlevel="full">
          <description>Maximum sensitivity that is implemented
          purely through analog gain.</description>
          <details>For camera.sensor.sensitivity values less than or
          equal to this, all applied gain must be analog. For
          values above this, the gain applied can be a mix of analog and
          digital.</details>
          <tag id="V1" />
          <tag id="FULL" />
        </entry>
        <entry name="orientation" type="int32" visibility="public"
               hwlevel="legacy">
          <description>Clockwise angle through which the output image needs to be rotated to be
          upright on the device screen in its native orientation.
          </description>
          <units>Degrees of clockwise rotation; always a multiple of
          90</units>
          <range>0, 90, 180, 270</range>
          <details>
          Also defines the direction of rolling shutter readout, which is from top to bottom in
          the sensor's coordinate system.
          </details>
          <tag id="BC" />
          <tag id="HALV3" />
        </entry>
        <entry name="profileHueSatMapDimensions" type="int32"
        visibility="system" optional="true"
        type_notes="Number of samples for hue, saturation, and value"
        container="array">
          <array>
            <size>3</size>
          </array>
          <description>
          The number of input samples for each dimension of
          camera.sensor.profileHueSatMap.
          </description>
          <range>
          Hue &amp;gt;= 1,
          Saturation &amp;gt;= 2,
          Value &amp;gt;= 1
          </range>
          <details>
          The number of input samples for the hue, saturation, and value
          dimension of camera.sensor.profileHueSatMap. The order of the
          dimensions given is hue, saturation, value; where hue is the 0th
          element.
          </details>
          <tag id="RAW" />
        </entry>
      </static>
      <dynamic>
        <clone entry="camera.sensor.exposureTime" kind="controls">
        </clone>
        <clone entry="camera.sensor.frameDuration"
        kind="controls"></clone>
        <clone entry="camera.sensor.sensitivity" kind="controls">
        </clone>
        <entry name="timestamp" type="int64" visibility="public"
               hwlevel="legacy">
          <description>Time at start of exposure of first
          row of the image sensor active array, in nanoseconds.</description>
          <units>Nanoseconds</units>
          <range>&amp;gt; 0</range>
          <details>The timestamps are also included in all image
          buffers produced for the same capture, and will be identical
          on all the outputs.

          When camera.sensor.info.timestampSource `==` UNKNOWN,
          the timestamps measure time since an unspecified starting point,
          and are monotonically increasing. They can be compared with the
          timestamps for other captures from the same camera device, but are
          not guaranteed to be comparable to any other time source.

          When camera.sensor.info.timestampSource `==` REALTIME,
          the timestamps measure time in the same timebase as
          camera.os.SystemClock#elapsedRealtimeNanos(), and they can be
          compared to other timestamps from other subsystems that are using
          that base.
          </details>
          <hal_details>
          All timestamps must be in reference to the kernel's
          CLOCK_BOOTTIME monotonic clock, which properly accounts for
          time spent asleep. This allows for synchronization with
          sensors that continue to operate while the system is
          otherwise asleep.

          If camera.sensor.info.timestampSource `==` REALTIME,
          The timestamp must be synchronized with the timestamps from other
          sensor subsystems that are using the same timebase.
          </hal_details>
          <tag id="BC" />
          <tag id="HALV3" />
        </entry>
        <entry name="temperature" type="float"
        optional="true">
          <description>The temperature of the sensor, sampled at the time
          exposure began for this frame.

          The thermal diode being queried should be inside the sensor PCB, or
          somewhere close to it.
          </description>

          <units>Celsius</units>
          <range>Optional. This value is missing if no temperature is available.</range>
          <tag id="FUTURE" />
        </entry>
        <entry name="neutralColorPoint" type="rational" visibility="public"
        optional="true" container="array">
          <array>
            <size>3</size>
          </array>
          <description>
          The estimated camera neutral color in the native sensor colorspace at
          the time of capture.
          </description>
          <details>
          This value gives the neutral color point encoded as an RGB value in the
          native sensor color space.  The neutral color point indicates the
          currently estimated white point of the scene illumination.  It can be
          used to interpolate between the provided color transforms when
          processing raw sensor data.

          The order of the values is R, G, B; where R is in the lowest index.
          </details>
          <tag id="RAW" />
        </entry>
        <entry name="noiseProfile" type="double" visibility="public"
        optional="true" type_notes="Pairs of noise model coefficients"
        container="array" typedef="pairDoubleDouble">
          <array>
            <size>2</size>
            <size>CFA Channels</size>
          </array>
          <description>
          Noise model coefficients for each CFA mosaic channel.
          </description>
          <details>
          This key contains two noise model coefficients for each CFA channel
          corresponding to the sensor amplification (S) and sensor readout
          noise (O).  These are given as pairs of coefficients for each channel
          in the same order as channels listed for the CFA layout key
          (see camera.sensor.info.colorFilterArrangement).  This is
          represented as an array of Pair&amp;lt;Double, Double&amp;gt;, where
          the first member of the Pair at index n is the S coefficient and the
          second member is the O coefficient for the nth color channel in the CFA.

          These coefficients are used in a two parameter noise model to describe
          the amount of noise present in the image for each CFA channel.  The
          noise model used here is:

          N(x) = sqrt(Sx + O)

          Where x represents the recorded signal of a CFA channel normalized to
          the range [0, 1], and S and O are the noise model coeffiecients for
          that channel.

          A more detailed description of the noise model can be found in the
          Adobe DNG specification for the NoiseProfile tag.
          </details>
          <hal_details>
          For a CFA layout of RGGB, the list of coefficients would be given as
          an array of doubles S0,O0,S1,O1,..., where S0 and O0 are the coefficients
          for the red channel, S1 and O1 are the coefficients for the first green
          channel, etc.
          </hal_details>
          <tag id="RAW" />
        </entry>
        <entry name="profileHueSatMap" type="float"
        visibility="system" optional="true"
        type_notes="Mapping for hue, saturation, and value"
        container="array">
          <array>
            <size>hue_samples</size>
            <size>saturation_samples</size>
            <size>value_samples</size>
            <size>3</size>
          </array>
          <description>
          A mapping containing a hue shift, saturation scale, and value scale
          for each pixel.
          </description>
          <units>
          The hue shift is given in degrees; saturation and value scale factors are
          unitless and are between 0 and 1 inclusive
          </units>
          <details>
          hue_samples, saturation_samples, and value_samples are given in
          camera.sensor.profileHueSatMapDimensions.

          Each entry of this map contains three floats corresponding to the
          hue shift, saturation scale, and value scale, respectively; where the
          hue shift has the lowest index. The map entries are stored in the key
          in nested loop order, with the value divisions in the outer loop, the
          hue divisions in the middle loop, and the saturation divisions in the
          inner loop. All zero input saturation entries are required to have a
          value scale factor of 1.0.
          </details>
          <tag id="RAW" />
        </entry>
        <entry name="profileToneCurve" type="float"
        visibility="system" optional="true"
        type_notes="Samples defining a spline for a tone-mapping curve"
        container="array">
          <array>
            <size>samples</size>
            <size>2</size>
          </array>
          <description>
          A list of x,y samples defining a tone-mapping curve for gamma adjustment.
          </description>
          <range>
          Each sample has an input range of `[0, 1]` and an output range of
          `[0, 1]`.  The first sample is required to be `(0, 0)`, and the last
          sample is required to be `(1, 1)`.
          </range>
          <details>
          This key contains a default tone curve that can be applied while
          processing the image as a starting point for user adjustments.
          The curve is specified as a list of value pairs in linear gamma.
          The curve is interpolated using a cubic spline.
          </details>
          <tag id="RAW" />
        </entry>
        <entry name="greenSplit" type="float" visibility="public" optional="true">
          <description>
          The worst-case divergence between Bayer green channels.
          </description>
          <range>
          &amp;gt;= 0
          </range>
          <details>
          This value is an estimate of the worst case split between the
          Bayer green channels in the red and blue rows in the sensor color
          filter array.

          The green split is calculated as follows:

          1. A 5x5 pixel (or larger) window W within the active sensor array is
          chosen. The term 'pixel' here is taken to mean a group of 4 Bayer
          mosaic channels (R, Gr, Gb, B).  The location and size of the window
          chosen is implementation defined, and should be chosen to provide a
          green split estimate that is both representative of the entire image
          for this camera sensor, and can be calculated quickly.
          1. The arithmetic mean of the green channels from the red
          rows (mean_Gr) within W is computed.
          1. The arithmetic mean of the green channels from the blue
          rows (mean_Gb) within W is computed.
          1. The maximum ratio R of the two means is computed as follows:
          `R = max((mean_Gr + 1)/(mean_Gb + 1), (mean_Gb + 1)/(mean_Gr + 1))`

          The ratio R is the green split divergence reported for this property,
          which represents how much the green channels differ in the mosaic
          pattern.  This value is typically used to determine the treatment of
          the green mosaic channels when demosaicing.

          The green split value can be roughly interpreted as follows:

          * R &amp;lt; 1.03 is a negligible split (&amp;lt;3% divergence).
          * 1.20 &amp;lt;= R &amp;gt;= 1.03 will require some software
          correction to avoid demosaic errors (3-20% divergence).
          * R &amp;gt; 1.20 will require strong software correction to produce
          a usuable image (&amp;gt;20% divergence).
          </details>
          <hal_details>
          The green split given may be a static value based on prior
          characterization of the camera sensor using the green split
          calculation method given here over a large, representative, sample
          set of images.  Other methods of calculation that produce equivalent
          results, and can be interpreted in the same manner, may be used.
          </hal_details>
          <tag id="RAW" />
        </entry>
      </dynamic>
      <controls>
        <entry name="testPatternData" type="int32" visibility="public" optional="true" container="array">
          <array>
            <size>4</size>
          </array>
          <description>
            A pixel `[R, G_even, G_odd, B]` that supplies the test pattern
            when camera.sensor.testPatternMode is SOLID_COLOR.
          </description>
          <details>
          Each color channel is treated as an unsigned 32-bit integer.
          The camera device then uses the most significant X bits
          that correspond to how many bits are in its Bayer raw sensor
          output.

          For example, a sensor with RAW10 Bayer output would use the
          10 most significant bits from each color channel.
          </details>
          <hal_details>
          </hal_details>
        </entry>
        <entry name="testPatternMode" type="int32" visibility="public" optional="true"
          enum="true">
          <enum>
            <value>OFF
              <notes>No test pattern mode is used, and the camera
              device returns captures from the image sensor.

              This is the default if the key is not set.</notes>
            </value>
            <value>SOLID_COLOR
              <notes>
              Each pixel in `[R, G_even, G_odd, B]` is replaced by its
              respective color channel provided in
              camera.sensor.testPatternData.

              For example:

                  camera.testPatternData = [0, 0xFFFFFFFF, 0xFFFFFFFF, 0]

              All green pixels are 100% green. All red/blue pixels are black.

                  camera.testPatternData = [0xFFFFFFFF, 0, 0xFFFFFFFF, 0]

              All red pixels are 100% red. Only the odd green pixels
              are 100% green. All blue pixels are 100% black.
              </notes>
            </value>
            <value>COLOR_BARS
              <notes>
              All pixel data is replaced with an 8-bar color pattern.

              The vertical bars (left-to-right) are as follows:

              * 100% white
              * yellow
              * cyan
              * green
              * magenta
              * red
              * blue
              * black

              In general the image would look like the following:

                 W Y C G M R B K
                 W Y C G M R B K
                 W Y C G M R B K
                 W Y C G M R B K
                 W Y C G M R B K
                 . . . . . . . .
                 . . . . . . . .
                 . . . . . . . .

                 (B = Blue, K = Black)

             Each bar should take up 1/8 of the sensor pixel array width.
             When this is not possible, the bar size should be rounded
             down to the nearest integer and the pattern can repeat
             on the right side.

             Each bar's height must always take up the full sensor
             pixel array height.

             Each pixel in this test pattern must be set to either
             0% intensity or 100% intensity.
             </notes>
            </value>
            <value>COLOR_BARS_FADE_TO_GRAY
              <notes>
              The test pattern is similar to COLOR_BARS, except that
              each bar should start at its specified color at the top,
              and fade to gray at the bottom.

              Furthermore each bar is further subdivided into a left and
              right half. The left half should have a smooth gradient,
              and the right half should have a quantized gradient.

              In particular, the right half's should consist of blocks of the
              same color for 1/16th active sensor pixel array width.

              The least significant bits in the quantized gradient should
              be copied from the most significant bits of the smooth gradient.

              The height of each bar should always be a multiple of 128.
              When this is not the case, the pattern should repeat at the bottom
              of the image.
              </notes>
            </value>
            <value>PN9
              <notes>
              All pixel data is replaced by a pseudo-random sequence
              generated from a PN9 512-bit sequence (typically implemented
              in hardware with a linear feedback shift register).

              The generator should be reset at the beginning of each frame,
              and thus each subsequent raw frame with this test pattern should
              be exactly the same as the last.
              </notes>
            </value>
            <value id="256">CUSTOM1
              <notes>The first custom test pattern. All custom patterns that are
              available only on this camera device are at least this numeric
              value.

              All of the custom test patterns will be static
              (that is the raw image must not vary from frame to frame).
              </notes>
            </value>
          </enum>
          <description>When enabled, the sensor sends a test pattern instead of
          doing a real exposure from the camera.
          </description>
          <range>camera.sensor.availableTestPatternModes</range>
          <details>
          When a test pattern is enabled, all manual sensor controls specified
          by camera.sensor.* will be ignored. All other controls should
          work as normal.

          For example, if manual flash is enabled, flash firing should still
          occur (and that the test pattern remain unmodified, since the flash
          would not actually affect it).

          Defaults to OFF.
          </details>
          <hal_details>
          All test patterns are specified in the Bayer domain.

          The HAL may choose to substitute test patterns from the sensor
          with test patterns from on-device memory. In that case, it should be
          indistinguishable to the ISP whether the data came from the
          sensor interconnect bus (such as CSI2) or memory.
          </hal_details>
        </entry>
      </controls>
      <dynamic>
        <clone entry="camera.sensor.testPatternData" kind="controls">
        </clone>
        <clone entry="camera.sensor.testPatternMode" kind="controls">
        </clone>
      </dynamic>
      <static>
        <entry name="availableTestPatternModes" type="int32" visibility="public" optional="true"
          type_notes="list of enums" container="array">
          <array>
            <size>n</size>
          </array>
          <description>List of sensor test pattern modes for camera.sensor.testPatternMode
          supported by this camera device.
          </description>
          <range>Any value listed in camera.sensor.testPatternMode</range>
          <details>
            Defaults to OFF, and always includes OFF if defined.
          </details>
          <hal_details>
            All custom modes must be >= CUSTOM1.
          </hal_details>
        </entry>
      </static>
      <dynamic>
        <entry name="rollingShutterSkew" type="int64" visibility="public" hwlevel="limited">
          <description>Duration between the start of first row exposure
          and the start of last row exposure.</description>
          <units>Nanoseconds</units>
          <range> &amp;gt;= 0 and &amp;lt;
          StreamConfigurationMap#getOutputMinFrameDuration(int, Size).</range>
          <details>
          This is the exposure time skew between the first and last
          row exposure start times. The first row and the last row are
          the first and last rows inside of the
          camera.sensor.info.activeArraySize.

          For typical camera sensors that use rolling shutters, this is also equivalent
          to the frame readout time.
          </details>
          <hal_details>
          The HAL must report `0` if the sensor is using global shutter, where all pixels begin
          exposure at the same time.
          </hal_details>
          <tag id="V1" />
        </entry>
      </dynamic>
    </section>
    <section name="shading">
      <controls>
        <entry name="mode" type="byte" visibility="public" enum="true" hwlevel="full">
          <enum>
            <value>OFF
            <notes>No lens shading correction is applied.</notes></value>
            <value>FAST
            <notes>Apply lens shading corrections, without slowing
            frame rate relative to sensor raw output</notes></value>
            <value>HIGH_QUALITY
            <notes>Apply high-quality lens shading correction, at the
            cost of reduced frame rate.</notes></value>
          </enum>
          <description>Quality of lens shading correction applied
          to the image data.</description>
          <details>
          When set to OFF mode, no lens shading correction will be applied by the
          camera device, and an identity lens shading map data will be provided
          if `camera.statistics.lensShadingMapMode == ON`. For example, for lens
          shading map with size of `[ 4, 3 ]`,
          the output camera.statistics.lensShadingCorrectionMap for this case will be an identity
          map shown below:

              [ 1.0, 1.0, 1.0, 1.0,  1.0, 1.0, 1.0, 1.0,
               1.0, 1.0, 1.0, 1.0,  1.0, 1.0, 1.0, 1.0,
               1.0, 1.0, 1.0, 1.0,  1.0, 1.0, 1.0, 1.0,
               1.0, 1.0, 1.0, 1.0,  1.0, 1.0, 1.0, 1.0,
               1.0, 1.0, 1.0, 1.0,  1.0, 1.0, 1.0, 1.0,
               1.0, 1.0, 1.0, 1.0,  1.0, 1.0, 1.0, 1.0 ]

          When set to other modes, lens shading correction will be applied by the camera
          device. Applications can request lens shading map data by setting
          camera.statistics.lensShadingMapMode to ON, and then the camera device will provide lens
          shading map data in camera.statistics.lensShadingCorrectionMap; the returned shading map
          data will be the one applied by the camera device for this capture request.

          The shading map data may depend on the auto-exposure (AE) and AWB statistics, therefore
          the reliability of the map data may be affected by the AE and AWB algorithms. When AE and
          AWB are in AUTO modes(camera.ae.mode `!=` OFF and camera.awb.mode `!=`
          OFF), to get best results, it is recommended that the applications wait for the AE and AWB
          to be converged before using the returned shading map data.
          </details>
        </entry>
        <entry name="strength" type="byte">
          <description>Control the amount of shading correction
          applied to the images</description>
          <units>unitless: 1-10; 10 is full shading
          compensation</units>
          <tag id="FUTURE" />
        </entry>
      </controls>
      <dynamic>
        <clone entry="camera.shading.mode" kind="controls">
        </clone>
      </dynamic>
    </section>
    <section name="statistics">
      <controls>
        <entry name="faceDetectMode" type="byte" visibility="public" enum="true"
               hwlevel="legacy">
          <enum>
            <value>OFF
            <notes>Do not include face detection statistics in capture
            results.</notes></value>
            <value optional="true">SIMPLE
            <notes>Return face rectangle and confidence values only.
            </notes></value>
            <value optional="true">FULL
            <notes>Return all face
            metadata.

            In this mode, face rectangles, scores, landmarks, and face IDs are all valid.
            </notes></value>
          </enum>
          <description>Operating mode for the face detector
          unit.</description>
          <range>camera.statistics.info.availableFaceDetectModes</range>
          <details>Whether face detection is enabled, and whether it
          should output just the basic fields or the full set of
          fields.</details>
          <hal_details>
            SIMPLE mode must fill in camera.statistics.faceRectangles and
            camera.statistics.faceScores.
            FULL mode must also fill in camera.statistics.faceIds, and
            camera.statistics.faceLandmarks.
          </hal_details>
          <tag id="BC" />
        </entry>
        <entry name="histogramMode" type="byte" enum="true" typedef="boolean">
          <enum>
            <value>OFF</value>
            <value>ON</value>
          </enum>
          <description>Operating mode for histogram
          generation</description>
          <tag id="FUTURE" />
        </entry>
        <entry name="sharpnessMapMode" type="byte" enum="true" typedef="boolean">
          <enum>
            <value>OFF</value>
            <value>ON</value>
          </enum>
          <description>Operating mode for sharpness map
          generation</description>
          <tag id="FUTURE" />
        </entry>
        <entry name="hotPixelMapMode" type="byte" visibility="public" enum="true"
        typedef="boolean">
          <enum>
            <value>OFF
            <notes>Hot pixel map production is disabled.
            </notes></value>
            <value>ON
            <notes>Hot pixel map production is enabled.
            </notes></value>
          </enum>
          <description>
          Operating mode for hot pixel map generation.
          </description>
          <range>camera.statistics.info.availableHotPixelMapModes</range>
          <details>
          If set to `true`, a hot pixel map is returned in camera.statistics.hotPixelMap.
          If set to `false`, no hot pixel map will be returned.
          </details>
          <tag id="V1" />
          <tag id="RAW" />
        </entry>
      </controls>
      <static>
        <namespace name="info">
          <entry name="availableFaceDetectModes" type="byte"
                 visibility="public"
                 type_notes="List of enums from camera.statistics.faceDetectMode"
                 container="array"
                 typedef="enumList"
                 hwlevel="legacy">
            <array>
              <size>n</size>
            </array>
            <description>List of face detection modes for camera.statistics.faceDetectMode that are
            supported by this camera device.
            </description>
            <range>Any value listed in camera.statistics.faceDetectMode</range>
            <details>OFF is always supported.
            </details>
          </entry>
          <entry name="histogramBucketCount" type="int32">
            <description>Number of histogram buckets
            supported</description>
            <range>&amp;gt;= 64</range>
            <tag id="FUTURE" />
          </entry>
          <entry name="maxFaceCount" type="int32" visibility="public" hwlevel="legacy">
            <description>The maximum number of simultaneously detectable
            faces.</description>
            <range>0 for cameras without available face detection; otherwise:
            `&gt;=4` for LIMITED or FULL hwlevel devices or
            `&gt;0` for LEGACY devices.</range>
            <tag id="BC" />
          </entry>
          <entry name="maxHistogramCount" type="int32">
            <description>Maximum value possible for a histogram
            bucket</description>
            <tag id="FUTURE" />
          </entry>
          <entry name="maxSharpnessMapValue" type="int32">
            <description>Maximum value possible for a sharpness map
            region.</description>
            <tag id="FUTURE" />
          </entry>
          <entry name="sharpnessMapSize" type="int32"
          type_notes="width x height" container="array" typedef="size">
            <array>
              <size>2</size>
            </array>
            <description>Dimensions of the sharpness
            map</description>
            <range>Must be at least 32 x 32</range>
            <tag id="FUTURE" />
          </entry>
          <entry name="availableHotPixelMapModes" type="byte" visibility="public"
                 type_notes="list of enums" container="array" typedef="boolean">
            <array>
              <size>n</size>
            </array>
            <description>
            List of hot pixel map output modes for camera.statistics.hotPixelMapMode that are
            supported by this camera device.
            </description>
            <range>Any value listed in camera.statistics.hotPixelMapMode</range>
            <details>
            If no hotpixel map output is available for this camera device, this will contain only
            `false`.

            ON is always supported on devices with the RAW capability.
            </details>
            <tag id="V1" />
            <tag id="RAW" />
          </entry>
        </namespace>
      </static>
      <dynamic>
        <clone entry="camera.statistics.faceDetectMode"
               kind="controls"></clone>
        <entry name="faceIds" type="int32" visibility="hidden" container="array"
               hwlevel="legacy">
          <array>
            <size>n</size>
          </array>
          <description>List of unique IDs for detected faces.</description>
          <details>
          Each detected face is given a unique ID that is valid for as long as the face is visible
          to the camera device.  A face that leaves the field of view and later returns may be
          assigned a new ID.

          Only available if camera.statistics.faceDetectMode == FULL</details>
          <tag id="BC" />
        </entry>
        <entry name="faceLandmarks" type="int32" visibility="hidden"
        type_notes="(leftEyeX, leftEyeY, rightEyeX, rightEyeY, mouthX, mouthY)"
        container="array" hwlevel="legacy">
          <array>
            <size>n</size>
            <size>6</size>
          </array>
          <description>List of landmarks for detected
          faces.</description>
          <details>
            The coordinate system is that of camera.sensor.info.activeArraySize, with
            `(0, 0)` being the top-left pixel of the active array.

            Only available if camera.statistics.faceDetectMode == FULL</details>
          <tag id="BC" />
        </entry>
        <entry name="faceRectangles" type="int32" visibility="hidden"
        type_notes="(xmin, ymin, xmax, ymax). (0,0) is top-left of active pixel area"
        container="array" typedef="rectangle" hwlevel="legacy">
          <array>
            <size>n</size>
            <size>4</size>
          </array>
          <description>List of the bounding rectangles for detected
          faces.</description>
          <details>
            The coordinate system is that of camera.sensor.info.activeArraySize, with
            `(0, 0)` being the top-left pixel of the active array.

            Only available if camera.statistics.faceDetectMode != OFF</details>
          <tag id="BC" />
        </entry>
        <entry name="faceScores" type="byte" visibility="hidden" container="array"
               hwlevel="legacy">
          <array>
            <size>n</size>
          </array>
          <description>List of the face confidence scores for
          detected faces</description>
          <range>1-100</range>
          <details>Only available if camera.statistics.faceDetectMode != OFF.
          </details>
          <hal_details>
          The value should be meaningful (for example, setting 100 at
          all times is illegal).</hal_details>
          <tag id="BC" />
        </entry>
        <entry name="faces" type="int32" visibility="public" synthetic="true"
               container="array" typedef="face" hwlevel="legacy">
          <array>
            <size>n</size>
          </array>
          <description>List of the faces detected through camera face detection
          in this capture.</description>
          <details>
          Only available if camera.statistics.faceDetectMode `!=` OFF.
          </details>
        </entry>
        <entry name="histogram" type="int32"
        type_notes="count of pixels for each color channel that fall into each histogram bucket, scaled to be between 0 and maxHistogramCount"
        container="array">
          <array>
            <size>n</size>
            <size>3</size>
          </array>
          <description>A 3-channel histogram based on the raw
          sensor data</description>
          <details>The k'th bucket (0-based) covers the input range
          (with w = camera.sensor.info.whiteLevel) of [ k * w/N,
          (k + 1) * w / N ). If only a monochrome sharpness map is
          supported, all channels should have the same data</details>
          <tag id="FUTURE" />
        </entry>
        <clone entry="camera.statistics.histogramMode"
        kind="controls"></clone>
        <entry name="sharpnessMap" type="int32"
        type_notes="estimated sharpness for each region of the input image. Normalized to be between 0 and maxSharpnessMapValue. Higher values mean sharper (better focused)"
        container="array">
          <array>
            <size>n</size>
            <size>m</size>
            <size>3</size>
          </array>
          <description>A 3-channel sharpness map, based on the raw
          sensor data</description>
          <details>If only a monochrome sharpness map is supported,
          all channels should have the same data</details>
          <tag id="FUTURE" />
        </entry>
        <clone entry="camera.statistics.sharpnessMapMode"
               kind="controls"></clone>
        <entry name="lensShadingCorrectionMap" type="byte" visibility="public"
               typedef="lensShadingMap" hwlevel="full">
          <description>The shading map is a low-resolution floating-point map
          that lists the coefficients used to correct for vignetting, for each
          Bayer color channel.</description>
          <range>Each gain factor is &amp;gt;= 1</range>
          <details>The least shaded section of the image should have a gain factor
          of 1; all other sections should have gains above 1.

          When camera.awb.mode = MANUAL_COLOR_TRANSFORM, the map
          must take into account the colorCorrection settings.

          The shading map is for the entire active pixel array, and is not
          affected by the crop region specified in the request. Each shading map
          entry is the value of the shading compensation map over a specific
          pixel on the sensor.  Specifically, with a (N x M) resolution shading
          map, and an active pixel array size (W x H), shading map entry
          (x,y)  (0 ... N-1, 0 ... M-1) is the value of the shading map at
          pixel ( ((W-1)/(N-1)) * x, ((H-1)/(M-1)) * y) for the four color channels.
          The map is assumed to be bilinearly interpolated between the sample points.

          The channel order is [R, Geven, Godd, B], where Geven is the green
          channel for the even rows of a Bayer pattern, and Godd is the odd rows.
          The shading map is stored in a fully interleaved format.

          The shading map should have on the order of 30-40 rows and columns,
          and must be smaller than 64x64.

          As an example, given a very small map defined as:

              width,height = [ 4, 3 ]
              values =
              [ 1.3, 1.2, 1.15, 1.2,  1.2, 1.2, 1.15, 1.2,
                  1.1, 1.2, 1.2, 1.2,  1.3, 1.2, 1.3, 1.3,
                1.2, 1.2, 1.25, 1.1,  1.1, 1.1, 1.1, 1.0,
                  1.0, 1.0, 1.0, 1.0,  1.2, 1.3, 1.25, 1.2,
                1.3, 1.2, 1.2, 1.3,   1.2, 1.15, 1.1, 1.2,
                  1.2, 1.1, 1.0, 1.2,  1.3, 1.15, 1.2, 1.3 ]

          The low-resolution scaling map images for each channel are
          (displayed using nearest-neighbor interpolation):

          ![Red lens shading map](camera.statistics.lensShadingMap/red_shading.png)
          ![Green (even rows) lens shading map](camera.statistics.lensShadingMap/green_e_shading.png)
          ![Green (odd rows) lens shading map](camera.statistics.lensShadingMap/green_o_shading.png)
          ![Blue lens shading map](camera.statistics.lensShadingMap/blue_shading.png)

          As a visualization only, inverting the full-color map to recover an
          image of a gray wall (using bicubic interpolation for visual quality) as captured by the sensor gives:

          ![Image of a uniform white wall (inverse shading map)](camera.statistics.lensShadingMap/inv_shading.png)
          </details>
        </entry>
        <entry name="lensShadingMap" type="float" visibility="hidden"
               type_notes="2D array of float gain factors per channel to correct lens shading"
               container="array" hwlevel="full">
          <array>
            <size>4</size>
            <size>n</size>
            <size>m</size>
          </array>
          <description>The shading map is a low-resolution floating-point map
          that lists the coefficients used to correct for vignetting, for each
          Bayer color channel.</description>
          <range>Each gain factor is &amp;gt;= 1</range>
          <details>The least shaded section of the image should have a gain factor
          of 1; all other sections should have gains above 1.

          When camera.awb.mode = MANUAL_COLOR_TRANSFORM, the map
          must take into account the colorCorrection settings.

          The shading map is for the entire active pixel array, and is not
          affected by the crop region specified in the request. Each shading map
          entry is the value of the shading compensation map over a specific
          pixel on the sensor.  Specifically, with a (N x M) resolution shading
          map, and an active pixel array size (W x H), shading map entry
          (x,y)  (0 ... N-1, 0 ... M-1) is the value of the shading map at
          pixel ( ((W-1)/(N-1)) * x, ((H-1)/(M-1)) * y) for the four color channels.
          The map is assumed to be bilinearly interpolated between the sample points.

          The channel order is [R, Geven, Godd, B], where Geven is the green
          channel for the even rows of a Bayer pattern, and Godd is the odd rows.
          The shading map is stored in a fully interleaved format, and its size
          is provided in the camera static metadata by camera.lens.info.shadingMapSize.

          The shading map should have on the order of 30-40 rows and columns,
          and must be smaller than 64x64.

          As an example, given a very small map defined as:

              camera.lens.info.shadingMapSize = [ 4, 3 ]
              camera.statistics.lensShadingMap =
              [ 1.3, 1.2, 1.15, 1.2,  1.2, 1.2, 1.15, 1.2,
                  1.1, 1.2, 1.2, 1.2,  1.3, 1.2, 1.3, 1.3,
                1.2, 1.2, 1.25, 1.1,  1.1, 1.1, 1.1, 1.0,
                  1.0, 1.0, 1.0, 1.0,  1.2, 1.3, 1.25, 1.2,
                1.3, 1.2, 1.2, 1.3,   1.2, 1.15, 1.1, 1.2,
                  1.2, 1.1, 1.0, 1.2,  1.3, 1.15, 1.2, 1.3 ]

          The low-resolution scaling map images for each channel are
          (displayed using nearest-neighbor interpolation):

          ![Red lens shading map](camera.statistics.lensShadingMap/red_shading.png)
          ![Green (even rows) lens shading map](camera.statistics.lensShadingMap/green_e_shading.png)
          ![Green (odd rows) lens shading map](camera.statistics.lensShadingMap/green_o_shading.png)
          ![Blue lens shading map](camera.statistics.lensShadingMap/blue_shading.png)

          As a visualization only, inverting the full-color map to recover an
          image of a gray wall (using bicubic interpolation for visual quality) as captured by the sensor gives:

          ![Image of a uniform white wall (inverse shading map)](camera.statistics.lensShadingMap/inv_shading.png)
          </details>
          <hal_details>
          The lens shading map calculation may depend on exposure and white balance statistics.
          When AE and AWB are in AUTO modes
          (camera.ae.mode `!=` OFF and camera.awb.mode `!=` OFF), the HAL
          may have all the information it need to generate most accurate lens shading map. When
          AE or AWB are in manual mode
          (camera.ae.mode `==` OFF or camera.awb.mode `==` OFF), the shading map
          may be adversely impacted by manual exposure or white balance parameters. To avoid
          generating unreliable shading map data, the HAL may choose to lock the shading map with
          the latest known good map generated when the AE and AWB are in AUTO modes.
          </hal_details>
        </entry>
        <entry name="predictedColorGains" type="float"
               visibility="hidden"
               deprecated="true"
               optional="true"
               type_notes="A 1D array of floats for 4 color channel gains"
               container="array">
          <array>
            <size>4</size>
          </array>
          <description>The best-fit color channel gains calculated
          by the camera device's statistics units for the current output frame.
          </description>
          <details>
          This may be different than the gains used for this frame,
          since statistics processing on data from a new frame
          typically completes after the transform has already been
          applied to that frame.

          The 4 channel gains are defined in Bayer domain,
          see camera.awb.colorGains for details.

          This value should always be calculated by the auto-white balance (AWB) block,
          regardless of the camera.control.* current values.
          </details>
        </entry>
        <entry name="predictedColorTransform" type="rational"
               visibility="hidden"
               deprecated="true"
               optional="true"
               type_notes="3x3 rational matrix in row-major order"
               container="array">
          <array>
            <size>3</size>
            <size>3</size>
          </array>
          <description>The best-fit color transform matrix estimate
          calculated by the camera device's statistics units for the current
          output frame.</description>
          <details>The camera device will provide the estimate from its
          statistics unit on the white balance transforms to use
          for the next frame. These are the values the camera device believes
          are the best fit for the current output frame. This may
          be different than the transform used for this frame, since
          statistics processing on data from a new frame typically
          completes after the transform has already been applied to
          that frame.

          These estimates must be provided for all frames, even if
          capture settings and color transforms are set by the application.

          This value should always be calculated by the auto-white balance (AWB) block,
          regardless of the camera.control.* current values.
          </details>
        </entry>
        <entry name="sceneFlicker" type="byte" visibility="public" enum="true"
               hwlevel="full">
          <enum>
            <value>NONE
            <notes>The camera device does not detect any flickering illumination
            in the current scene.</notes></value>
            <value>50HZ
            <notes>The camera device detects illumination flickering at 50Hz
            in the current scene.</notes></value>
            <value>60HZ
            <notes>The camera device detects illumination flickering at 60Hz
            in the current scene.</notes></value>
          </enum>
          <description>The camera device estimated scene illumination lighting
          frequency.</description>
          <details>
          Many light sources, such as most fluorescent lights, flicker at a rate
          that depends on the local utility power standards. This flicker must be
          accounted for by auto-exposure routines to avoid artifacts in captured images.
          The camera device uses this entry to tell the application what the scene
          illuminant frequency is.

          When manual exposure control is enabled
          (`camera.ae.mode == OFF` or `camera.control.mode ==
          OFF`), the camera.ae.antibandingMode doesn't perform
          antibanding, and the application can ensure it selects
          exposure times that do not cause banding issues by looking
          into this metadata field. See
          camera.ae.antibandingMode for more details.

          Reports NONE if there doesn't appear to be flickering illumination.
          </details>
        </entry>
        <clone entry="camera.statistics.hotPixelMapMode" kind="controls">
        </clone>
        <entry name="hotPixelMap" type="int32" visibility="public"
        type_notes="list of coordinates based on camera.sensor.pixelArraySize"
        container="array" typedef="point">
          <array>
            <size>2</size>
            <size>n</size>
          </array>
          <description>
          List of `(x, y)` coordinates of hot/defective pixels on the sensor.
          </description>
          <range>
          n &lt;= number of pixels on the sensor.
          The `(x, y)` coordinates must be bounded by
          camera.sensor.info.pixelArraySize.
          </range>
          <details>
          A coordinate `(x, y)` must lie between `(0, 0)`, and
          `(width - 1, height - 1)` (inclusive), which are the top-left and
          bottom-right of the pixel array, respectively. The width and
          height dimensions are given in camera.sensor.info.pixelArraySize.
          This may include hot pixels that lie outside of the active array
          bounds given by camera.sensor.info.activeArraySize.
          </details>
          <hal_details>
          A hotpixel map contains the coordinates of pixels on the camera
          sensor that do report valid values (usually due to defects in
          the camera sensor). This includes pixels that are stuck at certain
          values, or have a response that does not accuractly encode the
          incoming light from the scene.

          To avoid performance issues, there should be significantly fewer hot
          pixels than actual pixels on the camera sensor.
          </hal_details>
          <tag id="V1" />
          <tag id="RAW" />
        </entry>
      </dynamic>
      <controls>
        <entry name="lensShadingMapMode" type="byte" visibility="public" enum="true" hwlevel="full">
          <enum>
            <value>OFF
            <notes>Do not include a lens shading map in the capture result.</notes></value>
            <value>ON
            <notes>Include a lens shading map in the capture result.</notes></value>
          </enum>
          <description>Whether the camera device will output the lens
          shading map in output result metadata.</description>
          <details>When set to ON,
          camera.statistics.lensShadingMap will be provided in
          the output result metadata.

          ON is always supported on devices with the RAW capability.
          </details>
          <tag id="RAW" />
        </entry>
      </controls>
      <dynamic>
        <clone entry="camera.statistics.lensShadingMapMode" kind="controls">
        </clone>
      </dynamic>
    </section>
    <section name="tonemap">
      <controls>
        <entry name="curveBlue" type="float" visibility="hidden"
        type_notes="1D array of float pairs (P_IN, P_OUT). The maximum number of pairs is specified by camera.tonemap.maxCurvePoints."
        container="array" hwlevel="full">
          <array>
            <size>n</size>
            <size>2</size>
          </array>
          <description>Tonemapping / contrast / gamma curve for the blue
          channel, to use when camera.tonemap.mode is
          CONTRAST_CURVE.</description>
          <details>See camera.tonemap.curveRed for more details.</details>
        </entry>
        <entry name="curveGreen" type="float" visibility="hidden"
        type_notes="1D array of float pairs (P_IN, P_OUT). The maximum number of pairs is specified by camera.tonemap.maxCurvePoints."
        container="array" hwlevel="full">
          <array>
            <size>n</size>
            <size>2</size>
          </array>
          <description>Tonemapping / contrast / gamma curve for the green
          channel, to use when camera.tonemap.mode is
          CONTRAST_CURVE.</description>
          <details>See camera.tonemap.curveRed for more details.</details>
        </entry>
        <entry name="curveRed" type="float" visibility="hidden"
        type_notes="1D array of float pairs (P_IN, P_OUT). The maximum number of pairs is specified by camera.tonemap.maxCurvePoints."
        container="array" hwlevel="full">
          <array>
            <size>n</size>
            <size>2</size>
          </array>
          <description>Tonemapping / contrast / gamma curve for the red
          channel, to use when camera.tonemap.mode is
          CONTRAST_CURVE.</description>
          <range>0-1 on both input and output coordinates, normalized
          as a floating-point value such that 0 == black and 1 == white.
          </range>
          <details>
          Each channel's curve is defined by an array of control points:

              camera.tonemap.curveRed =
                [ P0in, P0out, P1in, P1out, P2in, P2out, P3in, P3out, ..., PNin, PNout ]
              2 &lt;= N &lt;= camera.tonemap.maxCurvePoints

          These are sorted in order of increasing `Pin`; it is
          required that input values 0.0 and 1.0 are included in the list to
          define a complete mapping. For input values between control points,
          the camera device must linearly interpolate between the control
          points.

          Each curve can have an independent number of points, and the number
          of points can be less than max (that is, the request doesn't have to
          always provide a curve with number of points equivalent to
          camera.tonemap.maxCurvePoints).

          A few examples, and their corresponding graphical mappings; these
          only specify the red channel and the precision is limited to 4
          digits, for conciseness.

          Linear mapping:

              camera.tonemap.curveRed = [ 0, 0, 1.0, 1.0 ]

          ![Linear mapping curve](camera.tonemap.curveRed/linear_tonemap.png)

          Invert mapping:

              camera.tonemap.curveRed = [ 0, 1.0, 1.0, 0 ]

          ![Inverting mapping curve](camera.tonemap.curveRed/inverse_tonemap.png)

          Gamma 1/2.2 mapping, with 16 control points:

              camera.tonemap.curveRed = [
                0.0000, 0.0000, 0.0667, 0.2920, 0.1333, 0.4002, 0.2000, 0.4812,
                0.2667, 0.5484, 0.3333, 0.6069, 0.4000, 0.6594, 0.4667, 0.7072,
                0.5333, 0.7515, 0.6000, 0.7928, 0.6667, 0.8317, 0.7333, 0.8685,
                0.8000, 0.9035, 0.8667, 0.9370, 0.9333, 0.9691, 1.0000, 1.0000 ]

          ![Gamma = 1/2.2 tonemapping curve](camera.tonemap.curveRed/gamma_tonemap.png)

          Standard sRGB gamma mapping, per IEC 61966-2-1:1999, with 16 control points:

              camera.tonemap.curveRed = [
                0.0000, 0.0000, 0.0667, 0.2864, 0.1333, 0.4007, 0.2000, 0.4845,
                0.2667, 0.5532, 0.3333, 0.6125, 0.4000, 0.6652, 0.4667, 0.7130,
                0.5333, 0.7569, 0.6000, 0.7977, 0.6667, 0.8360, 0.7333, 0.8721,
                0.8000, 0.9063, 0.8667, 0.9389, 0.9333, 0.9701, 1.0000, 1.0000 ]

          ![sRGB tonemapping curve](camera.tonemap.curveRed/srgb_tonemap.png)
        </details>
        <hal_details>
          For good quality of mapping, at least 128 control points are
          preferred.

          A typical use case of this would be a gamma-1/2.2 curve, with as many
          control points used as are available.
        </hal_details>
        </entry>
        <entry name="curve" type="float" visibility="public" synthetic="true"
               typedef="tonemapCurve"
               hwlevel="full">
          <description>Tonemapping / contrast / gamma curve to use when camera.tonemap.mode
          is CONTRAST_CURVE.</description>
          <details>
          The tonemapCurve consist of three curves for each of red, green, and blue
          channels respectively. The following example uses the red channel as an
          example. The same logic applies to green and blue channel.
          Each channel's curve is defined by an array of control points:

              curveRed =
                [ P0(in, out), P1(in, out), P2(in, out), P3(in, out), ..., PN(in, out) ]
              2 &lt;= N &lt;= camera.tonemap.maxCurvePoints

          These are sorted in order of increasing `Pin`; it is always
          guaranteed that input values 0.0 and 1.0 are included in the list to
          define a complete mapping. For input values between control points,
          the camera device must linearly interpolate between the control
          points.

          Each curve can have an independent number of points, and the number
          of points can be less than max (that is, the request doesn't have to
          always provide a curve with number of points equivalent to
          camera.tonemap.maxCurvePoints).

          A few examples, and their corresponding graphical mappings; these
          only specify the red channel and the precision is limited to 4
          digits, for conciseness.

          Linear mapping:

              curveRed = [ (0, 0), (1.0, 1.0) ]

          ![Linear mapping curve](camera.tonemap.curveRed/linear_tonemap.png)

          Invert mapping:

              curveRed = [ (0, 1.0), (1.0, 0) ]

          ![Inverting mapping curve](camera.tonemap.curveRed/inverse_tonemap.png)

          Gamma 1/2.2 mapping, with 16 control points:

              curveRed = [
                (0.0000, 0.0000), (0.0667, 0.2920), (0.1333, 0.4002), (0.2000, 0.4812),
                (0.2667, 0.5484), (0.3333, 0.6069), (0.4000, 0.6594), (0.4667, 0.7072),
                (0.5333, 0.7515), (0.6000, 0.7928), (0.6667, 0.8317), (0.7333, 0.8685),
                (0.8000, 0.9035), (0.8667, 0.9370), (0.9333, 0.9691), (1.0000, 1.0000) ]

          ![Gamma = 1/2.2 tonemapping curve](camera.tonemap.curveRed/gamma_tonemap.png)

          Standard sRGB gamma mapping, per IEC 61966-2-1:1999, with 16 control points:

              curveRed = [
                (0.0000, 0.0000), (0.0667, 0.2864), (0.1333, 0.4007), (0.2000, 0.4845),
                (0.2667, 0.5532), (0.3333, 0.6125), (0.4000, 0.6652), (0.4667, 0.7130),
                (0.5333, 0.7569), (0.6000, 0.7977), (0.6667, 0.8360), (0.7333, 0.8721),
                (0.8000, 0.9063), (0.8667, 0.9389), (0.9333, 0.9701), (1.0000, 1.0000) ]

          ![sRGB tonemapping curve](camera.tonemap.curveRed/srgb_tonemap.png)
        </details>
        <hal_details>
            This entry is created by the framework from the curveRed, curveGreen and
            curveBlue entries.
        </hal_details>
        </entry>
        <entry name="mode" type="byte" visibility="public" enum="true"
               hwlevel="full">
          <enum>
            <value>CONTRAST_CURVE
              <notes>Use the tone mapping curve specified in
              the camera.tonemap.curve* entries.

              All color enhancement and tonemapping must be disabled, except
              for applying the tonemapping curve specified by
              camera.tonemap.curve.

              Must not slow down frame rate relative to raw
              sensor output.
              </notes>
            </value>
            <value>FAST
              <notes>
              Advanced gamma mapping and color enhancement may be applied, without
              reducing frame rate compared to raw sensor output.
              </notes>
            </value>
            <value>HIGH_QUALITY
              <notes>
              High-quality gamma mapping and color enhancement will be applied, at
              the cost of reduced frame rate compared to raw sensor output.
              </notes>
            </value>
          </enum>
          <description>High-level global contrast/gamma/tonemapping control.
          </description>
          <range>camera.tonemap.availableToneMapModes</range>
          <details>
          When switching to an application-defined contrast curve by setting
          camera.tonemap.mode to CONTRAST_CURVE, the curve is defined
          per-channel with a set of `(in, out)` points that specify the
          mapping from input high-bit-depth pixel value to the output
          low-bit-depth value.  Since the actual pixel ranges of both input
          and output may change depending on the camera pipeline, the values
          are specified by normalized floating-point numbers.

          More-complex color mapping operations such as 3D color look-up
          tables, selective chroma enhancement, or other non-linear color
          transforms will be disabled when camera.tonemap.mode is
          CONTRAST_CURVE.

          When using either FAST or HIGH_QUALITY, the camera device will
          emit its own tonemap curve in camera.tonemap.curve.
          These values are always available, and as close as possible to the
          actually used nonlinear/nonglobal transforms.

          If a request is sent with CONTRAST_CURVE with the camera device's
          provided curve in FAST or HIGH_QUALITY, the image's tonemap will be
          roughly the same.</details>
        </entry>
      </controls>
      <static>
        <entry name="maxCurvePoints" type="int32" visibility="public"
               hwlevel="full">
          <description>Maximum number of supported points in the
            tonemap curve that can be used for camera.tonemap.curve.
          </description>
          <details>
          If the actual number of points provided by the application (in camera.tonemap.curve*) is
          less than this maximum, the camera device will resample the curve to its internal
          representation, using linear interpolation.

          The output curves in the result metadata may have a different number
          of points than the input curves, and will represent the actual
          hardware curves used as closely as possible when linearly interpolated.
          </details>
          <hal_details>
          This value must be at least 64. This should be at least 128.
          </hal_details>
        </entry>
        <entry name="availableToneMapModes" type="byte" visibility="public"
        type_notes="list of enums" container="array" typedef="enumList" hwlevel="full">
          <array>
            <size>n</size>
          </array>
          <description>
          List of tonemapping modes for camera.tonemap.mode that are supported by this camera
          device.
          </description>
          <range>Any value listed in camera.tonemap.mode</range>
          <details>
          Camera devices that support the MANUAL_POST_PROCESSING capability will always list
          CONTRAST_CURVE and FAST. This includes all FULL level devices.
          </details>
        </entry>
      </static>
      <dynamic>
        <clone entry="camera.tonemap.curveBlue" kind="controls">
        </clone>
        <clone entry="camera.tonemap.curveGreen" kind="controls">
        </clone>
        <clone entry="camera.tonemap.curveRed" kind="controls">
        </clone>
        <clone entry="camera.tonemap.curve" kind="controls">
        </clone>
        <clone entry="camera.tonemap.mode" kind="controls">
        </clone>
      </dynamic>
    </section>
    <section name="led">
      <controls>
        <entry name="transmit" type="byte" visibility="hidden" optional="true"
               enum="true" typedef="boolean">
          <enum>
            <value>OFF</value>
            <value>ON</value>
          </enum>
          <description>This LED is nominally used to indicate to the user
          that the camera is powered on and may be streaming images back to the
          Application Processor. In certain rare circumstances, the OS may
          disable this when video is processed locally and not transmitted to
          any untrusted applications.

          In particular, the LED *must* always be on when the data could be
          transmitted off the device. The LED *should* always be on whenever
          data is stored locally on the device.

          The LED *may* be off if a trusted application is using the data that
          doesn't violate the above rules.
          </description>
        </entry>
      </controls>
      <dynamic>
        <clone entry="camera.led.transmit" kind="controls"></clone>
      </dynamic>
      <static>
        <entry name="availableLeds" type="byte" visibility="hidden" optional="true"
               enum="true"
               container="array">
          <array>
            <size>n</size>
          </array>
          <enum>
            <value>TRANSMIT
              <notes>camera.led.transmit control is used.</notes>
            </value>
          </enum>
          <description>A list of camera LEDs that are available on this system.
          </description>
        </entry>
      </static>
    </section>
    <section name="info">
      <static>
        <entry name="supportedHardwareLevel" type="byte" visibility="public"
               enum="true" hwlevel="legacy">
          <enum>
            <value>
              LIMITED
              <notes>
              This camera device has only limited capabilities.
              </notes>
            </value>
            <value>
              FULL
              <notes>
              This camera device is capable of supporting advanced imaging applications.
              </notes>
            </value>
            <value>
              LEGACY
              <notes>
              This camera device is running in backward compatibility mode.
              </notes>
            </value>
          </enum>
          <description>
          Generally classifies the overall set of the camera device functionality.
          </description>
          <details>
          Camera devices will come in three flavors: LEGACY, LIMITED and FULL.

          A FULL device will support below capabilities:

          * 30fps operation at maximum resolution (== sensor resolution) is preferred, more than
            20fps is required, for at least uncompressed YUV
            output. (camera.request.availableCapabilities contains BURST_CAPTURE)
          * Per frame control (camera.sync.maxLatency `==` PER_FRAME_CONTROL)
          * Manual sensor control (camera.request.availableCapabilities contains MANUAL_SENSOR)
          * Manual post-processing control (camera.request.availableCapabilities contains
            MANUAL_POST_PROCESSING)
          * Arbitrary cropping region (camera.scaler.croppingType `==` FREEFORM)
          * At least 3 processed (but not stalling) format output streams
          * The required stream configuration defined in camera.scaler.availableStreamConfigurations
          * The required exposure time range defined in camera.sensor.info.exposureTimeRange
          * The required maxFrameDuration defined in camera.sensor.info.maxFrameDuration

          A LIMITED device may have some or none of the above characteristics.
          To find out more refer to camera.request.availableCapabilities.

          Some features are not part of any particular hardware level or capability and must be
          queried separately. These include:

          * Calibrated timestamps (camera.sensor.info.timestampSource `==` REALTIME)
          * Precision lens control (camera.lens.info.focusDistanceCalibration `==` CALIBRATED)
          * Face detection (camera.statistics.info.availableFaceDetectModes)
          * Optical or electrical image stabilization
            (camera.lens.info.availableOpticalStabilization,
             camera.control.availableVideoStabilizationModes)

          A LEGACY device does not support per-frame control, manual sensor control, manual
          post-processing, arbitrary cropping regions, and has relaxed performance constraints.

          Each higher level supports everything the lower level supports
          in this order: FULL `&gt;` LIMITED `&gt;` LEGACY.
          </details>
          <hal_details>
          The camera 3 HAL device can implement one of two possible
          operational modes; limited and full. Full support is
          expected from new higher-end devices. Limited mode has
          hardware requirements roughly in line with those for a
          camera HAL device v1 implementation, and is expected from
          older or inexpensive devices. Full is a strict superset of
          limited, and they share the same essential operational flow.

          For full details refer to "S3. Operational Modes" in camera3.h

          Camera HAL3+ must not implement LEGACY mode. It is there
          for backwards compatibility in the `camera.hardware.camera2`
          user-facing API only.
          </hal_details>
          <tag id="HALV3" />
        </entry>
      </static>
    </section>
    <section name="blackLevel">
      <controls>
        <entry name="lock" type="byte" visibility="public" enum="true"
               typedef="boolean" hwlevel="full">
          <enum>
            <value>OFF</value>
            <value>ON</value>
          </enum>
          <description> Whether black-level compensation is locked
          to its current values, or is free to vary.</description>
          <details>When set to `true` (ON), the values used for black-level
          compensation will not change until the lock is set to
          `false` (OFF).

          Since changes to certain capture parameters (such as
          exposure time) may require resetting of black level
          compensation, the camera device must report whether setting
          the black level lock was successful in the output result
          metadata.

          For example, if a sequence of requests is as follows:

          * Request 1: Exposure = 10ms, Black level lock = OFF
          * Request 2: Exposure = 10ms, Black level lock = ON
          * Request 3: Exposure = 10ms, Black level lock = ON
          * Request 4: Exposure = 20ms, Black level lock = ON
          * Request 5: Exposure = 20ms, Black level lock = ON
          * Request 6: Exposure = 20ms, Black level lock = ON

          And the exposure change in Request 4 requires the camera
          device to reset the black level offsets, then the output
          result metadata is expected to be:

          * Result 1: Exposure = 10ms, Black level lock = OFF
          * Result 2: Exposure = 10ms, Black level lock = ON
          * Result 3: Exposure = 10ms, Black level lock = ON
          * Result 4: Exposure = 20ms, Black level lock = OFF
          * Result 5: Exposure = 20ms, Black level lock = ON
          * Result 6: Exposure = 20ms, Black level lock = ON

          This indicates to the application that on frame 4, black
          levels were reset due to exposure value changes, and pixel
          values may not be consistent across captures.

          The camera device will maintain the lock to the extent
          possible, only overriding the lock to OFF when changes to
          other request parameters require a black level recalculation
          or reset.
          </details>
          <hal_details>
          If for some reason black level locking is no longer possible
          (for example, the analog gain has changed, which forces
          black level offsets to be recalculated), then the HAL must
          override this request (and it must report 'OFF' when this
          does happen) until the next capture for which locking is
          possible again.</hal_details>
          <tag id="HAL2" />
          <tag id="HALV3" />
        </entry>
      </controls>
      <dynamic>
        <clone entry="camera.blackLevel.lock"
          kind="controls">
          <details>
            Whether the black level offset was locked for this frame.  Should be
            ON if camera.blackLevel.lock was ON in the capture request, unless
            a change in other capture settings forced the camera device to
            perform a black level reset.
          </details>
          <tag id="HALV3" />
        </clone>
      </dynamic>
    </section>
    <section name="sync">
      <dynamic>
        <entry name="frameNumber" type="int64" visibility="hidden" enum="true"
               hwlevel="legacy">
          <enum>
            <value id="-1">CONVERGING
              <notes>
              The current result is not yet fully synchronized to any request.

              Synchronization is in progress, and reading metadata from this
              result may include a mix of data that have taken effect since the
              last synchronization time.

              In some future result, within camera.sync.maxLatency frames,
              this value will update to the actual frame number frame number
              the result is guaranteed to be synchronized to (as long as the
              request settings remain constant).
            </notes>
            </value>
            <value id="-2">UNKNOWN
              <notes>
              The current result's synchronization status is unknown.

              The result may have already converged, or it may be in
              progress.  Reading from this result may include some mix
              of settings from past requests.

              After a settings change, the new settings will eventually all
              take effect for the output buffers and results. However, this
              value will not change when that happens. Altering settings
              rapidly may provide outcomes using mixes of settings from recent
              requests.

              This value is intended primarily for backwards compatibility with
              the older camera implementations (for camera.hardware.Camera).
            </notes>
            </value>
          </enum>
          <description>The frame number corresponding to the last request
          with which the output result (metadata + buffers) has been fully
          synchronized.</description>
          <range>Either a non-negative value corresponding to a
          `frame_number`, or one of the two enums (CONVERGING / UNKNOWN).
          </range>
          <details>
          When a request is submitted to the camera device, there is usually a
          delay of several frames before the controls get applied. A camera
          device may either choose to account for this delay by implementing a
          pipeline and carefully submit well-timed atomic control updates, or
          it may start streaming control changes that span over several frame
          boundaries.

          In the latter case, whenever a request's settings change relative to
          the previous submitted request, the full set of changes may take
          multiple frame durations to fully take effect. Some settings may
          take effect sooner (in less frame durations) than others.

          While a set of control changes are being propagated, this value
          will be CONVERGING.

          Once it is fully known that a set of control changes have been
          finished propagating, and the resulting updated control settings
          have been read back by the camera device, this value will be set
          to a non-negative frame number (corresponding to the request to
          which the results have synchronized to).

          Older camera device implementations may not have a way to detect
          when all camera controls have been applied, and will always set this
          value to UNKNOWN.

          FULL capability devices will always have this value set to the
          frame number of the request corresponding to this result.

          _Further details_:

          * Whenever a request differs from the last request, any future
          results not yet returned may have this value set to CONVERGING (this
          could include any in-progress captures not yet returned by the camera
          device, for more details see pipeline considerations below).
          * Submitting a series of multiple requests that differ from the
          previous request (e.g. r1, r2, r3 s.t. r1 != r2 != r3)
          moves the new synchronization frame to the last non-repeating
          request (using the smallest frame number from the contiguous list of
          repeating requests).
          * Submitting the same request repeatedly will not change this value
          to CONVERGING, if it was already a non-negative value.
          * When this value changes to non-negative, that means that all of the
          metadata controls from the request have been applied, all of the
          metadata controls from the camera device have been read to the
          updated values (into the result), and all of the graphics buffers
          corresponding to this result are also synchronized to the request.

          _Pipeline considerations_:

          Submitting a request with updated controls relative to the previously
          submitted requests may also invalidate the synchronization state
          of all the results corresponding to currently in-flight requests.

          In other words, results for this current request and up to
          camera.request.pipelineMaxDepth prior requests may have their
          camera.sync.frameNumber change to CONVERGING.
          </details>
          <hal_details>
          Using UNKNOWN here is illegal unless camera.sync.maxLatency
          is also UNKNOWN.

          FULL capability devices should simply set this value to the
          `frame_number` of the request this result corresponds to.
          </hal_details>
          <tag id="V1" />
          <tag id="HALV3" />
        </entry>
      </dynamic>
      <static>
        <entry name="maxLatency" type="int32" visibility="public" enum="true"
               hwlevel="legacy">
          <enum>
            <value id="0">PER_FRAME_CONTROL
              <notes>
              Every frame has the requests immediately applied.

              Furthermore for all results,
              `camera.sync.frameNumber == CaptureResult#getFrameNumber()`

              Changing controls over multiple requests one after another will
              produce results that have those controls applied atomically
              each frame.

              All FULL capability devices will have this as their maxLatency.
              </notes>
            </value>
            <value id="-1">UNKNOWN
              <notes>
              Each new frame has some subset (potentially the entire set)
              of the past requests applied to the camera settings.

              By submitting a series of identical requests, the camera device
              will eventually have the camera settings applied, but it is
              unknown when that exact point will be.

              All LEGACY capability devices will have this as their maxLatency.
              </notes>
            </value>
          </enum>
          <description>
          The maximum number of frames that can occur after a request
          (different than the previous) has been submitted, and before the
          result's state becomes synchronized (by setting
          camera.sync.frameNumber to a non-negative value).
          </description>
          <units>Frame counts</units>
          <range>A positive value, PER_FRAME_CONTROL, or UNKNOWN.</range>
          <details>
          This defines the maximum distance (in number of metadata results),
          between camera.sync.frameNumber and the equivalent
          frame number for that result.

          In other words this acts as an upper boundary for how many frames
          must occur before the camera device knows for a fact that the new
          submitted camera settings have been applied in outgoing frames.

          For example if the distance was 2,

              initial request = X (repeating)
              request1 = X
              request2 = Y
              request3 = Y
              request4 = Y

              where requestN has frameNumber N, and the first of the repeating
              initial request's has frameNumber F (and F &lt; 1).

              initial result = X' + { camera.sync.frameNumber == F }
              result1 = X' + { camera.sync.frameNumber == F }
              result2 = X' + { camera.sync.frameNumber == CONVERGING }
              result3 = X' + { camera.sync.frameNumber == CONVERGING }
              result4 = X' + { camera.sync.frameNumber == 2 }

              where resultN has frameNumber N.

          Since `result4` has a `frameNumber == 4` and
          `camera.sync.frameNumber == 2`, the distance is clearly
          `4 - 2 = 2`.
          </details>
          <hal_details>
          Use `frame_count` from camera3_request_t.

          LIMITED devices are strongly encouraged to use a non-negative
          value. If UNKNOWN is used here then app developers do not have a way
          to know when sensor settings have been applied.
          </hal_details>
          <tag id="V1" />
          <tag id="HALV3" />
        </entry>
      </static>
    </section>
  </namespace>
  <namespace name="intel">
    <section name="info">
      <static>
        <entry name="availableFeatures" type="byte" visibility="public" enum="true" container="array">
          <array>
            <size>n</size>
          </array>
          <enum>
            <value id="0">MANUAL_EXPOSURE
              <notes>
                Allow user to controll exposure time and iso manually
              </notes>
            </value>
            <value id="1">MANUAL_WHITE_BALANCE
              <notes>
                Allow user to controll awb mode, cct range, and gain
              </notes>
            </value>
            <value id="2">IMAGE_ENHANCEMENT
              <notes>
                Sharpness, Brightness, Contrast, Hue, Saturation
              </notes>
            </value>
            <value id="3">NOISE_REDUCTION
              <notes>
                Allow user to control NR mode and NR level
              </notes>
            </value>
            <value id="4">SCENE_MODE
              <notes>
                Allow user to control scene mode
              </notes>
            </value>
            <value id="5">WEIGHT_GRID_MODE
              <notes>
                Allow user to control weight grid mode
              </notes>
            </value>
            <value id="6">PER_FRAME_CONTROL
              <notes>
                Allow user to control most of parameters for each frame
              </notes>
            </value>
            <value id="7">ISP_CONTROL
              <notes>
                Allow user to control most of parameters for each frame
              </notes>
            </value>
          </enum>
          <description>
          List all features supported by the device.
          </description>
        </entry>
        <entry name="aeExposureTimeRange" type="int32" visibility="public" container="array">
          <array>
            <size>3</size>
          </array>
          <description>Supported max and min exposure time values based on different scene mode.
          	Please refer to intel.control.sceneMode
          </description>
          <units>microsecond</units>
        </entry>
        <entry name="aeGainRange" type="int32" visibility="public" container="array">
          <array>
            <size>3</size>
          </array>
          <description>Supported max and min gain values based on different scene mode
          	Please refer to intel.control.sceneMode
          </description>
        </entry>
        <entry name="wfov" type="byte" visibility="public" enum="true" typedef="boolean">
          <enum>
            <value>OFF
              <notes>
                Sensor is in not a WFOV sensor or WFOV mode is disabled.
              </notes>
            </value>
            <value>ON
              <notes>
                Sensor WFOV mode is enabled, which allows view projection, rotation and fine adjustments.
              </notes>
            </value>
          </enum>
        </entry>
        <entry name="sensorMountType" type="byte" visibility="public" enum="true" typedef="enumList">
          <enum>
            <value>WALL_MOUNTED
              <notes>
                sensor is wall mounted.
              </notes>
            </value>
            <value>CEILING_MOUNTER
              <notes>
                sensor is ceiling mounted.
              </notes>
            </value>
          </enum>
        </entry>
      </static>
    </section>
    <section name="control">
      <controls>
        <entry name="imageEnhancement" type="int32" visibility="public">
          <description>
          To control sharpness, brightness, contrast, hue and saturation
          </description>
        </entry>

        <entry name="sensitivityGain" type="float" visibility="public">
          <description>Total gain of sensor.</description>
        </entry>

        <entry name="frameRate" type="float" visibility="public">
          <description>Control frame rate of capturing.</description>
        </entry>

        <entry name="aeConvergeSpeed" type="byte" visibility="public" enum="true">
          <enum>
            <value>NORMAL
              <notes>
                The AE converge speed is normal.
              </notes>
            </value>
            <value>MID
              <notes>
                The AE converge speed is mid.
              </notes>
            </value>
            <value>LOW
              <notes>
                The AE converge speed is low.
              </notes>
            </value>
          </enum>
          <description>Control converge speed of AE.</description>
        </entry>

        <entry name="nrMode" type="byte" visibility="public" enum="true">
          <enum>
            <value>OFF
              <notes>
                Turn off noise filter.
              </notes>
            </value>
            <value>AUTO
              <notes>
                Completely auto noise filter.
              </notes>
            </value>
            <value>MANUAL_NORMAL
              <notes>
                To control overall noise filter.
              </notes>
            </value>
            <value>MANUAL_EXPERT
              <notes>
                To control "spatial noise filter" and "temporal noise filter" separately
              </notes>
            </value>
          </enum>
          <description>
          To control noise reduction mode.
          </description>
        </entry>

        <entry name="nrLevel" type="int32" visibility="public" container="array">
          <array>
            <size>3</size>
          </array>
          <description>TO BE UPDATED</description>
        </entry>

        <entry name="irisMode" type="byte" visibility="public" enum="true">
          <enum>
            <value>AUTO
              <notes>
                TO BE UPDATED
              </notes>
            </value>
            <value>MANUAL
              <notes>
                TO BE UPDATED
              </notes>
            </value>
            <value>CUSTOMIZED
              <notes>
                TO BE UPDATED
              </notes>
            </value>
          </enum>
          <description>
          TO BE UPDATED
          </description>
        </entry>

        <entry name="aeDistributionPriority" type="byte" visibility="public" enum="true">
          <enum>
            <value>AUTO
              <notes>
                AEC internally prioritizes between exposure time, aperture and ISO when calculating distribution
              </notes>
            </value>
            <value>SHUTTER
              <notes>
                AEC tries to keep the exposure time at minimum until ISO and aperture are at maximum
              </notes>
            </value>
            <value>ISO
              <notes>
                AEC tries to keep the ISO at minimum until exposure time and aperture are at maximum
              </notes>
            </value>
            <value>APERTURE
              <notes>
                AEC tries to keep the aperture at minimum until exposure time and ISO are at maximum
              </notes>
            </value>
          </enum>
          <description>
            AEC exposure distribution priority modes
            This enumeration values are used to control distribution of AEC exposure parameters.
            For example in some situation user may want to keep aperture at smallest value (in order to have large DOF)
            as long as possible in expense of motion blur (caused by long exposure time) and noise (caused by high ISO)
          </description>
        </entry>

        <entry name="irisLevel" type="int32" visibility="public">
          <description>TO BE UPDATED</description>
        </entry>

        <entry name="wdrMode" type="byte" visibility="public" enum="true">
          <enum>
            <value>OFF
              <notes>
                TO BE UPDATED
              </notes>
            </value>
            <value>ON
              <notes>
                TO BE UPDATED
              </notes>
            </value>
            <value>AUTO
              <notes>
                TO BE UPDATED
              </notes>
            </value>
          </enum>
          <description>
          TO BE UPDATED
          </description>
        </entry>

        <entry name="wdrLevel" type="byte" visibility="public">
          <description>TO BE UPDATED</description>
        </entry>

        <entry name="blcAreaMode" type="byte" visibility="public" enum="true">
          <enum>
            <value>OFF
              <notes>
                TO BE UPDATED
              </notes>
            </value>
            <value>ON
              <notes>
                TO BE UPDATED
              </notes>
            </value>
          </enum>
          <description>
          TO BE UPDATED
          </description>
        </entry>

        <entry name="sceneMode" type="byte" visibility="public" enum="true">
          <enum>
            <value>AUTO
              <notes>
                TO BE UPDATED
              </notes>
            </value>
            <value>HDR
              <notes>
                TO BE UPDATED
              </notes>
            </value>
            <value>ULL
              <notes>
                TO BE UPDATED
              </notes>
            </value>
            <value>VIDEO_LL
              <notes>
                TO BE UPDATED
              </notes>
            </value>
            <value>HDR2
              <notes>
                TO BE UPDATED
              </notes>
            </value>
          </enum>
          <description>
          TO BE UPDATED
          </description>
        </entry>

        <entry name="weightGridMode" type="byte" visibility="public" enum="true">
          <enum>
            <value>AUTO
              <notes>
                TO BE UPDATED
              </notes>
            </value>
            <value>CUSTOM_WEIGHT_GRID1
              <notes>
                TO BE UPDATED
              </notes>
            </value>
            <value>CUSTOM_WEIGHT_GRID2
              <notes>
                TO BE UPDATED
              </notes>
            </value>
            <value>CUSTOM_WEIGHT_GRID3
              <notes>
                TO BE UPDATED
              </notes>
            </value>
          </enum>
          <description>
          TO BE UPDATED
          </description>
        </entry>

        <entry name="aeConvergeSpeedMode" type="byte" visibility="public" enum="true">
          <enum>
            <value>HAL
              <notes>
                Use HAL implement to control AE converge speed
              </notes>
            </value>
            <value>AIQ
              <notes>
                Use AIQ implement to control AE converge speed
              </notes>
            </value>
          </enum>
          <description>
            Control AE converge speed mode
          </description>
        </entry>

        <entry name="deinterlaceMode" type="byte" visibility="public" enum="true">
          <enum>
            <value>OFF
              <notes>
                Bypass mode, HAL doesn't hanlde the frame buffer.
              </notes>
            </value>
            <value>WEAVING
              <notes>
                Using FW to weave two frame buffer together.
              </notes>
            </value>
          </enum>
          <description>
            Control whether enable FW weaving function.
          </description>
        </entry>

        <entry name="makernoteData" type="byte" visibility="public">
          <description>The Makenote data in Intel format</description>
        </entry>

        <entry name="customAicParam" type="byte" visibility="public">
          <description>TO BE UPDATED</description>
        </entry>

        <entry name="makernoteMode" type="byte" visibility="public" enum="true">
          <enum>
            <value>OFF
              <notes>
                No makernote wasn't required
              </notes>
            </value>
            <value>JPEG
              <notes>
                The makernote for jpeg capture is required
              </notes>
            </value>
            <value>RAW
              <notes>
                The makernote for raw capture is required
              </notes>
            </value>
          </enum>
          <description>
            Control if makernote mode is required.
          </description>
        </entry>

        <entry name="yuvColorRange" type="byte" visibility="public" enum="true">
          <enum>
            <value>FULL
              <notes>
                Use full yuv color range
              </notes>
            </value>
            <value>REDUCED
              <notes>
                Use reduced yuv color range
              </notes>
            </value>
          </enum>
          <description>
            Control YUV color range mode
          </description>
        </entry>

        <entry name="sensitivityGainRange" type="float" visibility="public" container="array">
          <array>
            <size>2</size>
          </array>
          <description>
          The range of total gain of sensor.
          </description>
          <range>intel.info.aeGainRange</range>
        </entry>

        <entry name="exposureTimeRange" type="int32" visibility="public" container="array">
          <array>
            <size>3</size>
          </array>
          <description>
          The range of duration each pixel exposed to light.
          </description>
          <range>intel.info.aeExposureTimeRange</range>
        </entry>
        <entry name="fisheyeDewarpingMode" type="byte" visibility="public" enum="true">
          <enum>
            <value>OFF
              <notes>
                The dewarping is disabled.
              </notes>
            </value>
            <value>REARVIEW
              <notes>
                The dewarping mode is in rearview mode.
              </notes>
            </value>
            <value>HITCHVIEW
              <notes>
                The dewarping mode is in hitchview mode
              </notes>
            </value>
          </enum>
          <description>
            The fisheye dewarping modes
            This enumeration values are used to control the fisheye dewarping mode.
          </description>
        </entry>
        <entry name="ltmTuningData" type="byte" visibility="public" container="array">
          <array>
            <size>n</size>
          </array>
          <description>
          The tuning data for LTM(as knows as local tone map).
          </description>
        </entry>
        <entry name="digitalZoomRatio" type="float" visibility="public">
          <description>Set digital zoom ratio</description>
        </entry>
        <entry name="ldcMode" type="byte" visibility="public" enum="true">
          <enum>
            <value>OFF
              <notes>
                Lens distortion correction is OFF.
              </notes>
            </value>
            <value>ON
              <notes>
                Lens distortion correction is ON.
              </notes>
            </value>
          </enum>
          <description>
            This enumeration values are used to enable lens distortion correction.
          </description>
        </entry>
        <entry name="rscMode" type="byte" visibility="public" enum="true">
          <enum>
            <value>OFF
              <notes>
                Rolling shutter correction is OFF.
              </notes>
            </value>
            <value>ON
              <notes>
                Rolling shutter correction is ON.
              </notes>
            </value>
          </enum>
          <description>
            This enumeration values are used to enable rolling shutter correction.
          </description>
        </entry>
        <entry name="flipMode" type="byte" visibility="public" enum="true">
          <enum>
            <value>NONE
              <notes>
                No flip.
              </notes>
            </value>
            <value>VFLIP
              <notes>
                Vertical flip.
              </notes>
            </value>
            <value>HFLIP
              <notes>
                Horizontal flip.
              </notes>
            </value>
            <value>VHFLIP
              <notes>
                Both vertical and horizontal flip.
              </notes>
            </value>
          </enum>
          <description>
            These enumeration values are used to set flip mode.
          </description>
        </entry>
        <entry name="run3ACadence" type="int32" visibility="public">
          <description>Set the frame interval to run 3A.</description>
        </entry>
        <entry name="viewProjection" type="byte" visibility="public" container="array">
          <array><size>n</size></array>
          <description>To control camera view projection parameters in WFOV mode.</description>
        </entry>
        <entry name="viewRotation" type="byte" visibility="public" container="array">
          <array><size>n</size></array>
          <description>To control camera view rotation parameters in WFOV mode.</description>
        </entry>
        <entry name="viewFineAdjustments" type="byte" visibility="public" container="array">
          <array><size>n</size></array>
          <description>To control camera view fine adjustments parameters in WFOV mode.</description>
        </entry>
        <entry name="cameraRotation" type="byte" visibility="public" container="array">
          <array><size>n</size></array>
          <description>To control camera rotation parameters in WFOV mode.</description>
        </entry>
      </controls>
    </section>

    <section name="control_isp">
      <static>
        <entry name="supportedCtrlIds" type="int32" visibility="public" container="array">
          <array><size>n</size></array>
          <description>A list of supported ISP control feature IDs.</description>
        </entry>
      </static>

      <controls>
        <entry name="enabledCtrlIds" type="int32" visibility="public" container="array">
          <array><size>n</size></array>
          <description>A list of enabled ISP control feature IDs.</description>
        </entry>
        <entry name="wb_gains" type="byte" visibility="public" container="array">
          <array><size>n</size></array>
          <description>To control AWB gains such as GR, R, B and GB.</description>
        </entry>
        <entry name="color_correction_matrix" type="byte" visibility="public" container="array">
          <array><size>n</size></array>
          <description>To control the color correction matrix from sensor RGB to sRGB/target color space.</description>
        </entry>
        <entry name="advanced_color_correction_matrix" type="byte" visibility="public" container="array">
          <array><size>n</size></array>
          <description>
          Also known as ACM which stands advanced color correction matrix.
          It has more parameters and can give finer control than the normal CCM.
          </description>
        </entry>
        <entry name="bxt_csc" type="byte" visibility="public" container="array">
          <array><size>n</size></array>
          <description>To control color space conversion algo.</description>
        </entry>
        <entry name="bxt_demosaic" type="byte" visibility="public" container="array">
          <array><size>n</size></array>
          <description>To control demosaic related parameters.</description>
        </entry>
        <entry name="sc_iefd" type="byte" visibility="public" container="array">
          <array><size>n</size></array>
          <description>
            To control Image Enhancement Filter directed (IEFd) which is a block that denoises and
            sharpens edges on Luminance of the image.
          </description>
        </entry>
        <entry name="see" type="byte" visibility="public" container="array">
          <array><size>n</size></array>
          <description>
            To control Simple Edge Enhancement (SEE) which is a block that performs 5x5 DoG filter
            adaptive unsharpening mask method
          </description>
        </entry>
        <entry name="bnlm" type="byte" visibility="public" container="array">
          <array><size>n</size></array>
          <description>To control BNLM related parameters.</description>
        </entry>
        <entry name="tnr5_21" type="byte" visibility="public" container="array">
          <array><size>n</size></array>
          <description>To control TNR related parameters.</description>
        </entry>
        <entry name="xnr_dss" type="byte" visibility="public" container="array">
          <array><size>n</size></array>
          <description>To control XNR related parameters.</description>
        </entry>
        <entry name="gamma_tone_map" type="byte" visibility="public" container="array">
          <array><size>n</size></array>
          <description>To control gamma/tonemap related parameters.</description>
        </entry>
        <entry name="tnr5_22" type="byte" visibility="public" container="array">
          <array><size>n</size></array>
          <description>To control TNR 5.22 related parameters.</description>
        </entry>
        <entry name="tnr5_25" type="byte" visibility="public" container="array">
          <array><size>n</size></array>
          <description>To control TNR 5.25 related parameters.</description>
        </entry>
      </controls>
    </section>

  </namespace>
</metadata>
